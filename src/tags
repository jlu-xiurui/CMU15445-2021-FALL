!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABORT	include/recovery/log_record.h	/^  ABORT,$/;"	m	class:bustub::LogRecordType
APPLYDELETE	include/recovery/log_record.h	/^  APPLYDELETE,$/;"	m	class:bustub::LogRecordType
Abort	concurrency/transaction_manager.cpp	/^void TransactionManager::Abort(Transaction *txn) {$/;"	f	class:bustub::TransactionManager
AbortReason	include/concurrency/transaction.h	/^enum class AbortReason {$/;"	c	namespace:bustub
AbstractExecutor	include/execution/executors/abstract_executor.h	/^  explicit AbstractExecutor(ExecutorContext *exec_ctx) : exec_ctx_{exec_ctx} {}$/;"	f	class:bustub::AbstractExecutor
AbstractExecutor	include/execution/executors/abstract_executor.h	/^class AbstractExecutor {$/;"	c	namespace:bustub
AbstractExpression	include/execution/expressions/abstract_expression.h	/^  AbstractExpression(std::vector<const AbstractExpression *> &&children, TypeId ret_type)$/;"	f	class:bustub::AbstractExpression
AbstractExpression	include/execution/expressions/abstract_expression.h	/^class AbstractExpression {$/;"	c	namespace:bustub
AbstractPlanNode	include/execution/plans/abstract_plan.h	/^  AbstractPlanNode(const Schema *output_schema, std::vector<const AbstractPlanNode *> &&children)$/;"	f	class:bustub::AbstractPlanNode
AbstractPlanNode	include/execution/plans/abstract_plan.h	/^class AbstractPlanNode {$/;"	c	namespace:bustub
AbstractPool	include/type/abstract_pool.h	/^class AbstractPool {$/;"	c	namespace:bustub
Add	include/execution/plans/update_plan.h	/^enum class UpdateType { Add, Set };$/;"	m	class:bustub::UpdateType
Add	include/primer/p0_starter.h	/^  static std::unique_ptr<RowMatrix<T>> Add(const RowMatrix<T> *matrixA, const RowMatrix<T> *matrixB) {$/;"	f	class:bustub::RowMatrixOperations
AddBlockPageId	storage/page/hash_table_header_page.cpp	/^void HashTableHeaderPage::AddBlockPageId(page_id_t page_id) {}$/;"	f	class:bustub::HashTableHeaderPage
AddIntoDeletedPageSet	include/concurrency/transaction.h	/^  inline void AddIntoDeletedPageSet(page_id_t page_id) { deleted_page_set_->insert(page_id); }$/;"	f	class:bustub::Transaction
AddIntoPageSet	include/concurrency/transaction.h	/^  inline void AddIntoPageSet(Page *page) { page_set_->push_back(page); }$/;"	f	class:bustub::Transaction
AggregateKey	include/execution/plans/aggregation_plan.h	/^struct AggregateKey {$/;"	s	namespace:bustub
AggregateValue	include/execution/plans/aggregation_plan.h	/^struct AggregateValue {$/;"	s	namespace:bustub
AggregateValueExpression	include/execution/expressions/aggregate_value_expression.h	/^  AggregateValueExpression(bool is_group_by_term, uint32_t term_idx, TypeId ret_type)$/;"	f	class:bustub::AggregateValueExpression
AggregateValueExpression	include/execution/expressions/aggregate_value_expression.h	/^class AggregateValueExpression : public AbstractExpression {$/;"	c	namespace:bustub
Aggregation	include/execution/plans/abstract_plan.h	/^  Aggregation,$/;"	m	class:bustub::PlanType
AggregationExecutor	execution/aggregation_executor.cpp	/^AggregationExecutor::AggregationExecutor(ExecutorContext *exec_ctx, const AggregationPlanNode *plan,$/;"	f	class:bustub::AggregationExecutor
AggregationExecutor	include/execution/executors/aggregation_executor.h	/^class AggregationExecutor : public AbstractExecutor {$/;"	c	namespace:bustub
AggregationPlanNode	include/execution/plans/aggregation_plan.h	/^  AggregationPlanNode(const Schema *output_schema, const AbstractPlanNode *child, const AbstractExpression *having,$/;"	f	class:bustub::AggregationPlanNode
AggregationPlanNode	include/execution/plans/aggregation_plan.h	/^class AggregationPlanNode : public AbstractPlanNode {$/;"	c	namespace:bustub
AggregationType	include/execution/plans/aggregation_plan.h	/^enum class AggregationType { CountAggregate, SumAggregate, MinAggregate, MaxAggregate };$/;"	c	namespace:bustub
AllocatePage	buffer/buffer_pool_manager_instance.cpp	/^page_id_t BufferPoolManagerInstance::AllocatePage() {$/;"	f	class:bustub::BufferPoolManagerInstance
AppendIndexWriteRecord	include/concurrency/transaction.h	/^  inline void AppendIndexWriteRecord(const IndexWriteRecord &write_record) {$/;"	f	class:bustub::Transaction
AppendTableWriteRecord	include/concurrency/transaction.h	/^  inline void AppendTableWriteRecord(const TableWriteRecord &write_record) {$/;"	f	class:bustub::Transaction
ApplyDelete	storage/page/table_page.cpp	/^void TablePage::ApplyDelete(const RID &rid, Transaction *txn, LogManager *log_manager) {$/;"	f	class:bustub::TablePage
ApplyDelete	storage/table/table_heap.cpp	/^void TableHeap::ApplyDelete(const RID &rid, Transaction *txn) {$/;"	f	class:bustub::TableHeap
BEFORE	include/buffer/buffer_pool_manager.h	/^  enum class CallbackType { BEFORE, AFTER };$/;"	m	class:bustub::BufferPoolManager::CallbackType
BEGIN	include/recovery/log_record.h	/^  BEGIN,$/;"	m	class:bustub::LogRecordType
BIGINT	include/type/type_id.h	/^enum TypeId { INVALID = 0, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, VARCHAR, TIMESTAMP };$/;"	e	enum:bustub::TypeId
BIGINT_COMPARE_FUNC	type/bigint_type.cpp	20;"	d	file:
BIGINT_MODIFY_FUNC	type/bigint_type.cpp	40;"	d	file:
BLOCK_ARRAY_SIZE	include/storage/page/hash_table_page_defs.h	29;"	d
BOOLEAN	include/type/type_id.h	/^enum TypeId { INVALID = 0, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, VARCHAR, TIMESTAMP };$/;"	e	enum:bustub::TypeId
BOOLEAN_COMPARE_FUNC	type/boolean_type.cpp	19;"	d	file:
BPLUSTREE_INDEX_TYPE	include/storage/index/b_plus_tree_index.h	24;"	d
BPLUSTREE_TYPE	include/storage/index/b_plus_tree.h	24;"	d
BPlusTree	include/storage/index/b_plus_tree.h	/^class BPlusTree {$/;"	c	namespace:bustub
BPlusTree	storage/index/b_plus_tree.cpp	/^BPLUSTREE_TYPE::BPlusTree(std::string name, BufferPoolManager *buffer_pool_manager, const KeyComparator &comparator,$/;"	f	class:bustub::BPLUSTREE_TYPE
BPlusTreeIndex	include/storage/index/b_plus_tree_index.h	/^class BPlusTreeIndex : public Index {$/;"	c	namespace:bustub
BPlusTreeIndex	storage/index/b_plus_tree_index.cpp	/^BPLUSTREE_INDEX_TYPE::BPlusTreeIndex(std::unique_ptr<IndexMetadata> &&metadata, BufferPoolManager *buffer_pool_manager)$/;"	f	class:bustub::BPLUSTREE_INDEX_TYPE
BPlusTreeInternalPage	include/storage/page/b_plus_tree_internal_page.h	/^class BPlusTreeInternalPage : public BPlusTreePage {$/;"	c	namespace:bustub
BPlusTreeLeafPage	include/storage/page/b_plus_tree_leaf_page.h	/^class BPlusTreeLeafPage : public BPlusTreePage {$/;"	c	namespace:bustub
BPlusTreePage	include/storage/page/b_plus_tree_page.h	/^class BPlusTreePage {$/;"	c	namespace:bustub
BUCKET_ARRAY_SIZE	include/storage/page/hash_table_page_defs.h	44;"	d
BUCKET_SIZE	include/common/config.h	/^static constexpr int BUCKET_SIZE = 50;                                        \/\/ size of extendible hash bucket$/;"	m	namespace:bustub
BUFFER_POOL_SIZE	include/common/config.h	/^static constexpr int BUFFER_POOL_SIZE = 10;                                   \/\/ size of buffer pool$/;"	m	namespace:bustub
BUSTUB_ASSERT	include/common/macros.h	20;"	d
BUSTUB_BOOLEAN_MAX	include/type/limits.h	/^static constexpr int8_t BUSTUB_BOOLEAN_MAX = 1;$/;"	m	namespace:bustub
BUSTUB_BOOLEAN_MIN	include/type/limits.h	/^static constexpr int8_t BUSTUB_BOOLEAN_MIN = 0;$/;"	m	namespace:bustub
BUSTUB_BOOLEAN_NULL	include/type/limits.h	/^static constexpr int8_t BUSTUB_BOOLEAN_NULL = SCHAR_MIN;$/;"	m	namespace:bustub
BUSTUB_DATE_MAX	include/type/limits.h	/^static constexpr uint64_t BUSTUB_DATE_MAX = INT_MAX;$/;"	m	namespace:bustub
BUSTUB_DATE_MIN	include/type/limits.h	/^static constexpr uint32_t BUSTUB_DATE_MIN = 0;$/;"	m	namespace:bustub
BUSTUB_DATE_NULL	include/type/limits.h	/^static constexpr uint64_t BUSTUB_DATE_NULL = 0;$/;"	m	namespace:bustub
BUSTUB_DECIMAL_MAX	include/type/limits.h	/^static constexpr double BUSTUB_DECIMAL_MAX = DBL_MAX;$/;"	m	namespace:bustub
BUSTUB_DECIMAL_MIN	include/type/limits.h	/^static constexpr double BUSTUB_DECIMAL_MIN = FLT_LOWEST;$/;"	m	namespace:bustub
BUSTUB_DECIMAL_NULL	include/type/limits.h	/^static constexpr double BUSTUB_DECIMAL_NULL = DBL_LOWEST;$/;"	m	namespace:bustub
BUSTUB_INT16_MAX	include/type/limits.h	/^static constexpr int16_t BUSTUB_INT16_MAX = SHRT_MAX;$/;"	m	namespace:bustub
BUSTUB_INT16_MIN	include/type/limits.h	/^static constexpr int16_t BUSTUB_INT16_MIN = (SHRT_MIN + 1);$/;"	m	namespace:bustub
BUSTUB_INT16_NULL	include/type/limits.h	/^static constexpr int16_t BUSTUB_INT16_NULL = SHRT_MIN;$/;"	m	namespace:bustub
BUSTUB_INT32_MAX	include/type/limits.h	/^static constexpr int32_t BUSTUB_INT32_MAX = INT_MAX;$/;"	m	namespace:bustub
BUSTUB_INT32_MIN	include/type/limits.h	/^static constexpr int32_t BUSTUB_INT32_MIN = (INT_MIN + 1);$/;"	m	namespace:bustub
BUSTUB_INT32_NULL	include/type/limits.h	/^static constexpr int32_t BUSTUB_INT32_NULL = INT_MIN;$/;"	m	namespace:bustub
BUSTUB_INT64_MAX	include/type/limits.h	/^static constexpr int64_t BUSTUB_INT64_MAX = LLONG_MAX;$/;"	m	namespace:bustub
BUSTUB_INT64_MIN	include/type/limits.h	/^static constexpr int64_t BUSTUB_INT64_MIN = (LLONG_MIN + 1);$/;"	m	namespace:bustub
BUSTUB_INT64_NULL	include/type/limits.h	/^static constexpr int64_t BUSTUB_INT64_NULL = LLONG_MIN;$/;"	m	namespace:bustub
BUSTUB_INT8_MAX	include/type/limits.h	/^static constexpr int8_t BUSTUB_INT8_MAX = SCHAR_MAX;$/;"	m	namespace:bustub
BUSTUB_INT8_MIN	include/type/limits.h	/^static constexpr int8_t BUSTUB_INT8_MIN = (SCHAR_MIN + 1);$/;"	m	namespace:bustub
BUSTUB_INT8_NULL	include/type/limits.h	/^static constexpr int8_t BUSTUB_INT8_NULL = SCHAR_MIN;$/;"	m	namespace:bustub
BUSTUB_TEXT_MAX_LEN	include/type/limits.h	/^static constexpr uint32_t BUSTUB_TEXT_MAX_LEN = 1000000000;$/;"	m	namespace:bustub
BUSTUB_TIMESTAMP_MAX	include/type/limits.h	/^static constexpr uint64_t BUSTUB_TIMESTAMP_MAX = 11231999986399999999U;$/;"	m	namespace:bustub
BUSTUB_TIMESTAMP_MIN	include/type/limits.h	/^static constexpr uint64_t BUSTUB_TIMESTAMP_MIN = 0;$/;"	m	namespace:bustub
BUSTUB_TIMESTAMP_NULL	include/type/limits.h	/^static constexpr uint64_t BUSTUB_TIMESTAMP_NULL = ULLONG_MAX;$/;"	m	namespace:bustub
BUSTUB_UINT64_MAX	include/type/limits.h	/^static constexpr uint64_t BUSTUB_UINT64_MAX = ULLONG_MAX - 1;$/;"	m	namespace:bustub
BUSTUB_VALUE_NULL	include/type/limits.h	/^static constexpr uint32_t BUSTUB_VALUE_NULL = UINT_MAX;$/;"	m	namespace:bustub
BUSTUB_VARCHAR_MAX_LEN	include/type/limits.h	/^static constexpr uint32_t BUSTUB_VARCHAR_MAX_LEN = UINT_MAX;$/;"	m	namespace:bustub
B_PLUS_TREE_INTERNAL_PAGE_TYPE	include/storage/page/b_plus_tree_internal_page.h	19;"	d
B_PLUS_TREE_LEAF_PAGE_TYPE	include/storage/page/b_plus_tree_leaf_page.h	20;"	d
Begin	include/execution/executors/aggregation_executor.h	/^  Iterator Begin() { return Iterator{ht_.cbegin()}; }$/;"	f	class:bustub::SimpleAggregationHashTable
BeginCheckpoint	recovery/checkpoint_manager.cpp	/^void CheckpointManager::BeginCheckpoint() {$/;"	f	class:bustub::CheckpointManager
BigintType	include/type/bigint_type.h	/^class BigintType : public IntegerParentType {$/;"	c	namespace:bustub
BigintType	type/bigint_type.cpp	/^BigintType::BigintType() : IntegerParentType(BIGINT) {}$/;"	f	class:bustub::BigintType
BlockAllTransactions	concurrency/transaction_manager.cpp	/^void TransactionManager::BlockAllTransactions() { global_txn_latch_.WLock(); }$/;"	f	class:bustub::TransactionManager
BooleanType	include/type/boolean_type.h	/^class BooleanType : public Type {$/;"	c	namespace:bustub
BooleanType	type/boolean_type.cpp	/^BooleanType::BooleanType() : Type(TypeId::BOOLEAN) {}$/;"	f	class:bustub::BooleanType
BufferPoolManager	include/buffer/buffer_pool_manager.h	/^class BufferPoolManager {$/;"	c	namespace:bustub
BufferPoolManager	include/buffer/parallel_buffer_pool_manager.h	/^  auto GetBufferPoolManager(page_id_t page_id) -> BufferPoolManager *;$/;"	m	class:bustub::ParallelBufferPoolManager
BufferPoolManagerInstance	buffer/buffer_pool_manager_instance.cpp	/^BufferPoolManagerInstance::BufferPoolManagerInstance(size_t pool_size, DiskManager *disk_manager,$/;"	f	class:bustub::BufferPoolManagerInstance
BufferPoolManagerInstance	buffer/buffer_pool_manager_instance.cpp	/^BufferPoolManagerInstance::BufferPoolManagerInstance(size_t pool_size, uint32_t num_instances, uint32_t instance_index,$/;"	f	class:bustub::BufferPoolManagerInstance
BufferPoolManagerInstance	include/buffer/buffer_pool_manager_instance.h	/^class BufferPoolManagerInstance : public BufferPoolManager {$/;"	c	namespace:bustub
BustubInstance	include/common/bustub_instance.h	/^  explicit BustubInstance(const std::string &db_file_name) {$/;"	f	class:bustub::BustubInstance
BustubInstance	include/common/bustub_instance.h	/^class BustubInstance {$/;"	c	namespace:bustub
COMMIT	include/recovery/log_record.h	/^  COMMIT,$/;"	m	class:bustub::LogRecordType
COMMITTED	include/concurrency/transaction.h	/^enum class TransactionState { GROWING, SHRINKING, COMMITTED, ABORTED };$/;"	m	class:bustub::TransactionState
CONVERSION	include/common/exception.h	/^  CONVERSION = 2,$/;"	m	class:bustub::ExceptionType
CallbackType	include/buffer/buffer_pool_manager.h	/^  enum class CallbackType { BEFORE, AFTER };$/;"	c	class:bustub::BufferPoolManager
CanShrink	storage/page/hash_table_directory_page.cpp	/^bool HashTableDirectoryPage::CanShrink() {$/;"	f	class:bustub::HashTableDirectoryPage
Catalog	include/catalog/catalog.h	/^  Catalog(BufferPoolManager *bpm, LockManager *lock_manager, LogManager *log_manager)$/;"	f	class:bustub::Catalog
Catalog	include/catalog/catalog.h	/^class Catalog {$/;"	c	namespace:bustub
CheckpointManager	include/recovery/checkpoint_manager.h	/^  CheckpointManager(TransactionManager *transaction_manager, LogManager *log_manager,$/;"	f	class:bustub::CheckpointManager
CheckpointManager	include/recovery/checkpoint_manager.h	/^class CheckpointManager {$/;"	c	namespace:bustub
ClockReplacer	buffer/clock_replacer.cpp	/^ClockReplacer::ClockReplacer(size_t num_pages) {}$/;"	f	class:bustub::ClockReplacer
ClockReplacer	include/buffer/clock_replacer.h	/^class ClockReplacer : public Replacer {$/;"	c	namespace:bustub
CmpBool	include/type/type.h	/^  virtual auto CompareEquals(const Value &left, const Value &right) const -> CmpBool;$/;"	m	class:bustub::CmpBool::Type
CmpBool	include/type/type.h	/^  virtual auto CompareGreaterThan(const Value &left, const Value &right) const -> CmpBool;$/;"	m	class:bustub::CmpBool::Type
CmpBool	include/type/type.h	/^  virtual auto CompareGreaterThanEquals(const Value &left, const Value &right) const -> CmpBool;$/;"	m	class:bustub::CmpBool::Type
CmpBool	include/type/type.h	/^  virtual auto CompareLessThan(const Value &left, const Value &right) const -> CmpBool;$/;"	m	class:bustub::CmpBool::Type
CmpBool	include/type/type.h	/^  virtual auto CompareLessThanEquals(const Value &left, const Value &right) const -> CmpBool;$/;"	m	class:bustub::CmpBool::Type
CmpBool	include/type/type.h	/^  virtual auto CompareNotEquals(const Value &left, const Value &right) const -> CmpBool;$/;"	m	class:bustub::CmpBool::Type
CmpBool	include/type/type.h	/^enum class CmpBool { CmpFalse = 0, CmpTrue = 1, CmpNull = 2 };$/;"	c	namespace:bustub
CmpFalse	include/type/type.h	/^enum class CmpBool { CmpFalse = 0, CmpTrue = 1, CmpNull = 2 };$/;"	m	class:bustub::CmpBool
CmpNull	include/type/type.h	/^enum class CmpBool { CmpFalse = 0, CmpTrue = 1, CmpNull = 2 };$/;"	m	class:bustub::CmpBool
CmpTrue	include/type/type.h	/^enum class CmpBool { CmpFalse = 0, CmpTrue = 1, CmpNull = 2 };$/;"	m	class:bustub::CmpBool
Column	include/catalog/column.h	/^  Column(std::string column_name, TypeId type, const AbstractExpression *expr = nullptr)$/;"	f	class:bustub::Column
Column	include/catalog/column.h	/^  Column(std::string column_name, TypeId type, uint32_t length, const AbstractExpression *expr = nullptr)$/;"	f	class:bustub::Column
Column	include/catalog/column.h	/^class Column {$/;"	c	namespace:bustub
ColumnInsertMeta	include/catalog/table_generator.h	/^    ColumnInsertMeta(const char *name, const TypeId type, bool nullable, Dist dist, uint64_t min, uint64_t max)$/;"	f	struct:bustub::TableGenerator::ColumnInsertMeta
ColumnInsertMeta	include/catalog/table_generator.h	/^  struct ColumnInsertMeta {$/;"	s	class:bustub::TableGenerator
ColumnValueExpression	include/execution/expressions/column_value_expression.h	/^  ColumnValueExpression(uint32_t tuple_idx, uint32_t col_idx, TypeId ret_type)$/;"	f	class:bustub::ColumnValueExpression
ColumnValueExpression	include/execution/expressions/column_value_expression.h	/^class ColumnValueExpression : public AbstractExpression {$/;"	c	namespace:bustub
CombineAggregateValues	include/execution/executors/aggregation_executor.h	/^  void CombineAggregateValues(AggregateValue *result, const AggregateValue &input) {$/;"	f	class:bustub::SimpleAggregationHashTable
Commit	concurrency/transaction_manager.cpp	/^void TransactionManager::Commit(Transaction *txn) {$/;"	f	class:bustub::TransactionManager
ComparisonExpression	include/execution/expressions/comparison_expression.h	/^  ComparisonExpression(const AbstractExpression *left, const AbstractExpression *right, ComparisonType comp_type)$/;"	f	class:bustub::ComparisonExpression
ComparisonExpression	include/execution/expressions/comparison_expression.h	/^class ComparisonExpression : public AbstractExpression {$/;"	c	namespace:bustub
ComparisonType	include/execution/expressions/comparison_expression.h	/^enum class ComparisonType { Equal, NotEqual, LessThan, LessThanOrEqual, GreaterThan, GreaterThanOrEqual };$/;"	c	namespace:bustub
ConstantValueExpression	include/execution/expressions/constant_value_expression.h	/^  explicit ConstantValueExpression(const Value &val) : AbstractExpression({}, val.GetTypeId()), val_(val) {}$/;"	f	class:bustub::ConstantValueExpression
ConstantValueExpression	include/execution/expressions/constant_value_expression.h	/^class ConstantValueExpression : public AbstractExpression {$/;"	c	namespace:bustub
CopyFirstFrom	storage/page/b_plus_tree_internal_page.cpp	/^void B_PLUS_TREE_INTERNAL_PAGE_TYPE::CopyFirstFrom(const MappingType &pair, BufferPoolManager *buffer_pool_manager) {}$/;"	f	class:bustub::B_PLUS_TREE_INTERNAL_PAGE_TYPE
CopyFirstFrom	storage/page/b_plus_tree_leaf_page.cpp	/^void B_PLUS_TREE_LEAF_PAGE_TYPE::CopyFirstFrom(const MappingType &item) {}$/;"	f	class:bustub::B_PLUS_TREE_LEAF_PAGE_TYPE
CopyLastFrom	storage/page/b_plus_tree_internal_page.cpp	/^void B_PLUS_TREE_INTERNAL_PAGE_TYPE::CopyLastFrom(const MappingType &pair, BufferPoolManager *buffer_pool_manager) {}$/;"	f	class:bustub::B_PLUS_TREE_INTERNAL_PAGE_TYPE
CopyLastFrom	storage/page/b_plus_tree_leaf_page.cpp	/^void B_PLUS_TREE_LEAF_PAGE_TYPE::CopyLastFrom(const MappingType &item) {}$/;"	f	class:bustub::B_PLUS_TREE_LEAF_PAGE_TYPE
CopyNFrom	storage/page/b_plus_tree_internal_page.cpp	/^void B_PLUS_TREE_INTERNAL_PAGE_TYPE::CopyNFrom(MappingType *items, int size, BufferPoolManager *buffer_pool_manager) {}$/;"	f	class:bustub::B_PLUS_TREE_INTERNAL_PAGE_TYPE
CopyNFrom	storage/page/b_plus_tree_leaf_page.cpp	/^void B_PLUS_TREE_LEAF_PAGE_TYPE::CopyNFrom(MappingType *items, int size) {}$/;"	f	class:bustub::B_PLUS_TREE_LEAF_PAGE_TYPE
CountAggregate	include/execution/plans/aggregation_plan.h	/^enum class AggregationType { CountAggregate, SumAggregate, MinAggregate, MaxAggregate };$/;"	m	class:bustub::AggregationType
DBL_LOWEST	include/type/limits.h	/^static constexpr double DBL_LOWEST = std::numeric_limits<double>::lowest();$/;"	m	namespace:bustub
DEADLOCK	include/concurrency/transaction.h	/^  DEADLOCK,$/;"	m	class:bustub::AbortReason
DECIMAL	include/common/exception.h	/^  DECIMAL = 4,$/;"	m	class:bustub::ExceptionType
DECIMAL	include/type/type_id.h	/^enum TypeId { INVALID = 0, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, VARCHAR, TIMESTAMP };$/;"	e	enum:bustub::TypeId
DECIMAL_COMPARE_FUNC	type/decimal_type.cpp	22;"	d	file:
DECIMAL_MODIFY_FUNC	type/decimal_type.cpp	42;"	d	file:
DELETE	include/concurrency/transaction.h	/^enum class WType { INSERT = 0, DELETE, UPDATE };$/;"	m	class:bustub::WType
DELETE_MASK	include/storage/page/table_page.h	/^static constexpr uint64_t DELETE_MASK = (1U << (8 * sizeof(uint32_t) - 1));$/;"	v
DIRECTORY_ARRAY_SIZE	include/storage/page/hash_table_page_defs.h	35;"	d
DISALLOW_COPY	include/common/macros.h	25;"	d
DISALLOW_COPY_AND_MOVE	include/common/macros.h	33;"	d
DISALLOW_MOVE	include/common/macros.h	29;"	d
DIVIDE_BY_ZERO	include/common/exception.h	/^  DIVIDE_BY_ZERO = 6,$/;"	m	class:bustub::ExceptionType
DeallocatePage	include/buffer/buffer_pool_manager_instance.h	/^  void DeallocatePage(__attribute__((unused)) page_id_t page_id) {$/;"	f	class:bustub::BufferPoolManagerInstance
DecimalType	include/type/decimal_type.h	/^class DecimalType : public NumericType {$/;"	c	namespace:bustub
DecimalType	type/decimal_type.cpp	/^DecimalType::DecimalType() : NumericType(TypeId::DECIMAL) {}$/;"	f	class:bustub::DecimalType
DecrGlobalDepth	storage/page/hash_table_directory_page.cpp	/^void HashTableDirectoryPage::DecrGlobalDepth() { global_depth_--; }$/;"	f	class:bustub::HashTableDirectoryPage
DecrLocalDepth	storage/page/hash_table_directory_page.cpp	/^void HashTableDirectoryPage::DecrLocalDepth(uint32_t bucket_idx) { local_depths_[bucket_idx]--; }$/;"	f	class:bustub::HashTableDirectoryPage
Delete	include/execution/plans/abstract_plan.h	/^  Delete,$/;"	m	class:bustub::PlanType
DeleteEntry	storage/index/b_plus_tree_index.cpp	/^void BPLUSTREE_INDEX_TYPE::DeleteEntry(const Tuple &key, RID rid, Transaction *transaction) {$/;"	f	class:bustub::BPLUSTREE_INDEX_TYPE
DeleteEntry	storage/index/extendible_hash_table_index.cpp	/^void HASH_TABLE_INDEX_TYPE::DeleteEntry(const Tuple &key, RID rid, Transaction *transaction) {$/;"	f	class:bustub::HASH_TABLE_INDEX_TYPE
DeleteEntry	storage/index/linear_probe_hash_table_index.cpp	/^void HASH_TABLE_INDEX_TYPE::DeleteEntry(const Tuple &key, RID rid, Transaction *transaction) {$/;"	f	class:bustub::HASH_TABLE_INDEX_TYPE
DeleteExecutor	execution/delete_executor.cpp	/^DeleteExecutor::DeleteExecutor(ExecutorContext *exec_ctx, const DeletePlanNode *plan,$/;"	f	class:bustub::DeleteExecutor
DeleteExecutor	include/execution/executors/delete_executor.h	/^class DeleteExecutor : public AbstractExecutor {$/;"	c	namespace:bustub
DeleteNode	buffer/lru_replacer.cpp	/^void LRUReplacer::DeleteNode(LinkListNode *curr) {$/;"	f	class:bustub::LRUReplacer
DeletePgImp	buffer/buffer_pool_manager_instance.cpp	/^bool BufferPoolManagerInstance::DeletePgImp(page_id_t page_id) {$/;"	f	class:bustub::BufferPoolManagerInstance
DeletePlanNode	include/execution/plans/delete_plan.h	/^  DeletePlanNode(const AbstractPlanNode *child, table_oid_t table_oid)$/;"	f	class:bustub::DeletePlanNode
DeletePlanNode	include/execution/plans/delete_plan.h	/^class DeletePlanNode : public AbstractPlanNode {$/;"	c	namespace:bustub
DeserializeFrom	storage/table/tuple.cpp	/^void Tuple::DeserializeFrom(const char *storage) {$/;"	f	class:bustub::Tuple
DiskManager	include/storage/disk/disk_manager.h	/^class DiskManager {$/;"	c	namespace:bustub
DiskManager	storage/disk/disk_manager.cpp	/^DiskManager::DiskManager(const std::string &db_file)$/;"	f	class:bustub::DiskManager
Dist	include/catalog/table_generator.h	/^  enum class Dist : uint8_t { Uniform, Zipf_50, Zipf_75, Zipf_95, Zipf_99, Serial, Cyclic };$/;"	c	class:bustub::TableGenerator
Distinct	include/execution/plans/abstract_plan.h	/^  Distinct,$/;"	m	class:bustub::PlanType
DistinctExecutor	execution/distinct_executor.cpp	/^DistinctExecutor::DistinctExecutor(ExecutorContext *exec_ctx, const DistinctPlanNode *plan,$/;"	f	class:bustub::DistinctExecutor
DistinctExecutor	include/execution/executors/distinct_executor.h	/^class DistinctExecutor : public AbstractExecutor {$/;"	c	namespace:bustub
DistinctKey	include/execution/executors/distinct_executor.h	/^struct DistinctKey {$/;"	s	namespace:bustub
DistinctPlanNode	include/execution/plans/distinct_plan.h	/^  DistinctPlanNode(const Schema *output_schema, const AbstractPlanNode *child)$/;"	f	class:bustub::DistinctPlanNode
DistinctPlanNode	include/execution/plans/distinct_plan.h	/^class DistinctPlanNode : public AbstractPlanNode {$/;"	c	namespace:bustub
Draw	storage/index/b_plus_tree.cpp	/^void BPLUSTREE_TYPE::Draw(BufferPoolManager *bpm, const std::string &outf) {$/;"	f	class:bustub::BPLUSTREE_TYPE
End	include/execution/executors/aggregation_executor.h	/^  Iterator End() { return Iterator{ht_.cend()}; }$/;"	f	class:bustub::SimpleAggregationHashTable
EndCheckpoint	recovery/checkpoint_manager.cpp	/^void CheckpointManager::EndCheckpoint() {$/;"	f	class:bustub::CheckpointManager
Equal	include/execution/expressions/comparison_expression.h	/^enum class ComparisonType { Equal, NotEqual, LessThan, LessThanOrEqual, GreaterThan, GreaterThanOrEqual };$/;"	m	class:bustub::ComparisonType
Exception	include/common/exception.h	/^  Exception(ExceptionType exception_type, const std::string &message)$/;"	f	class:bustub::Exception
Exception	include/common/exception.h	/^  explicit Exception(const std::string &message) : std::runtime_error(message), type_(ExceptionType::INVALID) {$/;"	f	class:bustub::Exception
Exception	include/common/exception.h	/^class Exception : public std::runtime_error {$/;"	c	namespace:bustub
ExceptionType	include/common/exception.h	/^enum class ExceptionType {$/;"	c	namespace:bustub
Execute	include/execution/execution_engine.h	/^  bool Execute(const AbstractPlanNode *plan, std::vector<Tuple> *result_set, Transaction *txn,$/;"	f	class:bustub::ExecutionEngine
ExecutionEngine	include/execution/execution_engine.h	/^  ExecutionEngine(BufferPoolManager *bpm, TransactionManager *txn_mgr, Catalog *catalog)$/;"	f	class:bustub::ExecutionEngine
ExecutionEngine	include/execution/execution_engine.h	/^class ExecutionEngine {$/;"	c	namespace:bustub
ExecutorContext	include/execution/executor_context.h	/^  ExecutorContext(Transaction *transaction, Catalog *catalog, BufferPoolManager *bpm, TransactionManager *txn_mgr,$/;"	f	class:bustub::ExecutorContext
ExecutorContext	include/execution/executor_context.h	/^class ExecutorContext {$/;"	c	namespace:bustub
ExecutorFactory	include/execution/executor_factory.h	/^class ExecutorFactory {$/;"	c	namespace:bustub
ExtendibleHashTable	container/hash/extendible_hash_table.cpp	/^HASH_TABLE_TYPE::ExtendibleHashTable(const std::string &name, BufferPoolManager *buffer_pool_manager,$/;"	f	class:bustub::HASH_TABLE_TYPE
ExtendibleHashTable	include/container/hash/extendible_hash_table.h	/^class ExtendibleHashTable {$/;"	c	namespace:bustub
ExtendibleHashTableIndex	include/storage/index/extendible_hash_table_index.h	/^class ExtendibleHashTableIndex : public Index {$/;"	c	namespace:bustub
ExtendibleHashTableIndex	storage/index/extendible_hash_table_index.cpp	/^HASH_TABLE_INDEX_TYPE::ExtendibleHashTableIndex(std::unique_ptr<IndexMetadata> &&metadata,$/;"	f	class:bustub::HASH_TABLE_INDEX_TYPE
FLT_LOWEST	include/type/limits.h	/^static constexpr double FLT_LOWEST = std::numeric_limits<float>::lowest();$/;"	m	namespace:bustub
FetchBucketPage	container/hash/extendible_hash_table.cpp	/^HASH_TABLE_BUCKET_TYPE *HASH_TABLE_TYPE::FetchBucketPage(page_id_t bucket_page_id) {$/;"	f	class:bustub::HASH_TABLE_TYPE
FetchDirectoryPage	container/hash/extendible_hash_table.cpp	/^HashTableDirectoryPage *HASH_TABLE_TYPE::FetchDirectoryPage() {$/;"	f	class:bustub::HASH_TABLE_TYPE
FetchPgImp	buffer/buffer_pool_manager_instance.cpp	/^Page *BufferPoolManagerInstance::FetchPgImp(page_id_t page_id) {$/;"	f	class:bustub::BufferPoolManagerInstance
FillTable	catalog/table_generator.cpp	/^void TableGenerator::FillTable(TableInfo *info, TableInsertMeta *table_meta) {$/;"	f	class:bustub::TableGenerator
FlushAllPages	include/buffer/buffer_pool_manager.h	/^  void FlushAllPages(bufferpool_callback_fn callback = nullptr) {$/;"	f	class:bustub::BufferPoolManager
FlushAllPgsImp	buffer/buffer_pool_manager_instance.cpp	/^void BufferPoolManagerInstance::FlushAllPgsImp() {$/;"	f	class:bustub::BufferPoolManagerInstance
FlushAllPgsImp	buffer/parallel_buffer_pool_manager.cpp	/^void ParallelBufferPoolManager::FlushAllPgsImp() {$/;"	f	class:bustub::ParallelBufferPoolManager
FlushPgImp	buffer/buffer_pool_manager_instance.cpp	/^bool BufferPoolManagerInstance::FlushPgImp(page_id_t page_id) {$/;"	f	class:bustub::BufferPoolManagerInstance
Format	common/util/string_util.cpp	/^std::string StringUtil::Format(std::string fmt_str, ...) {$/;"	f	class:bustub::StringUtil
GEMM	include/primer/p0_starter.h	/^  static std::unique_ptr<RowMatrix<T>> GEMM(const RowMatrix<T> *matrixA, const RowMatrix<T> *matrixB,$/;"	f	class:bustub::RowMatrixOperations
GROWING	include/concurrency/transaction.h	/^enum class TransactionState { GROWING, SHRINKING, COMMITTED, ABORTED };$/;"	m	class:bustub::TransactionState
GenerateInitialAggregateValue	include/execution/executors/aggregation_executor.h	/^  AggregateValue GenerateInitialAggregateValue() {$/;"	f	class:bustub::SimpleAggregationHashTable
GenerateTestTables	catalog/table_generator.cpp	/^void TableGenerator::GenerateTestTables() {$/;"	f	class:bustub::TableGenerator
GenerateUpdatedTuple	execution/update_executor.cpp	/^Tuple UpdateExecutor::GenerateUpdatedTuple(const Tuple &src_tuple) {$/;"	f	class:bustub::UpdateExecutor
GenericComparator	include/storage/index/generic_key.h	/^  GenericComparator(const GenericComparator &other) : key_schema_{other.key_schema_} {}$/;"	f	class:bustub::GenericComparator
GenericComparator	include/storage/index/generic_key.h	/^  explicit GenericComparator(Schema *key_schema) : key_schema_(key_schema) {}$/;"	f	class:bustub::GenericComparator
GenericComparator	include/storage/index/generic_key.h	/^class GenericComparator {$/;"	c	namespace:bustub
GenericKey	include/storage/index/generic_key.h	/^class GenericKey {$/;"	c	namespace:bustub
GetBucketPageId	storage/page/hash_table_directory_page.cpp	/^page_id_t HashTableDirectoryPage::GetBucketPageId(uint32_t bucket_idx) { return bucket_page_ids_[bucket_idx]; }$/;"	f	class:bustub::HashTableDirectoryPage
GetChildAt	include/execution/plans/abstract_plan.h	/^  const AbstractPlanNode *GetChildAt(uint32_t child_idx) const { return children_[child_idx]; }$/;"	f	class:bustub::AbstractPlanNode
GetChildExecutor	execution/aggregation_executor.cpp	/^const AbstractExecutor *AggregationExecutor::GetChildExecutor() const { return child_.get(); }$/;"	f	class:bustub::AggregationExecutor
GetChildren	include/execution/plans/abstract_plan.h	/^  const std::vector<const AbstractPlanNode *> &GetChildren() const { return children_; }$/;"	f	class:bustub::AbstractPlanNode
GetGlobalDepth	container/hash/extendible_hash_table.cpp	/^uint32_t HASH_TABLE_TYPE::GetGlobalDepth() {$/;"	f	class:bustub::HASH_TABLE_TYPE
GetGlobalDepth	storage/page/hash_table_directory_page.cpp	/^uint32_t HashTableDirectoryPage::GetGlobalDepth() { return global_depth_; }$/;"	f	class:bustub::HashTableDirectoryPage
GetGlobalDepthMask	storage/page/hash_table_directory_page.cpp	/^uint32_t HashTableDirectoryPage::GetGlobalDepthMask() { return (1U << global_depth_) - 1; }$/;"	f	class:bustub::HashTableDirectoryPage
GetLSN	storage/page/hash_table_directory_page.cpp	/^lsn_t HashTableDirectoryPage::GetLSN() const { return lsn_; }$/;"	f	class:bustub::HashTableDirectoryPage
GetLocalDepth	storage/page/hash_table_directory_page.cpp	/^uint32_t HashTableDirectoryPage::GetLocalDepth(uint32_t bucket_idx) { return local_depths_[bucket_idx]; }$/;"	f	class:bustub::HashTableDirectoryPage
GetLocalHighBit	storage/page/hash_table_directory_page.cpp	/^uint32_t HashTableDirectoryPage::GetLocalHighBit(uint32_t bucket_idx) {$/;"	f	class:bustub::HashTableDirectoryPage
GetOutputSchema	include/execution/executors/mock_scan_executor.h	/^  const Schema *GetOutputSchema() const { return plan_->OutputSchema(); }$/;"	f	class:bustub::MockScanExecutor
GetPageId	storage/page/hash_table_directory_page.cpp	/^page_id_t HashTableDirectoryPage::GetPageId() const { return page_id_; }$/;"	f	class:bustub::HashTableDirectoryPage
GetPages	include/buffer/buffer_pool_manager_instance.h	/^  Page *GetPages() { return pages_; }$/;"	f	class:bustub::BufferPoolManagerInstance
GetSize	include/execution/plans/mock_scan_plan.h	/^  std::size_t GetSize() const { return size_; }$/;"	f	class:bustub::MockScanPlanNode
GetSplitImageIndex	storage/page/hash_table_directory_page.cpp	/^uint32_t HashTableDirectoryPage::GetSplitImageIndex(uint32_t bucket_idx) {$/;"	f	class:bustub::HashTableDirectoryPage
GetValue	container/hash/extendible_hash_table.cpp	/^bool HASH_TABLE_TYPE::GetValue(Transaction *transaction, const KeyType &key, std::vector<ValueType> *result) {$/;"	f	class:bustub::HASH_TABLE_TYPE
GetValue	storage/page/hash_table_bucket_page.cpp	/^bool HASH_TABLE_BUCKET_TYPE::GetValue(KeyType key, KeyComparator cmp, std::vector<ValueType> *result) {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
GradingCallback	include/buffer/buffer_pool_manager.h	/^  void GradingCallback(bufferpool_callback_fn callback, CallbackType callback_type, page_id_t page_id) {$/;"	f	class:bustub::BufferPoolManager
GreaterThan	include/execution/expressions/comparison_expression.h	/^enum class ComparisonType { Equal, NotEqual, LessThan, LessThanOrEqual, GreaterThan, GreaterThanOrEqual };$/;"	m	class:bustub::ComparisonType
HASH_TABLE_BLOCK_TYPE	include/storage/page/hash_table_page_defs.h	20;"	d
HASH_TABLE_BUCKET_TYPE	include/storage/page/hash_table_page_defs.h	34;"	d
HASH_TABLE_INDEX_TYPE	include/storage/index/extendible_hash_table_index.h	26;"	d
HASH_TABLE_INDEX_TYPE	include/storage/index/linear_probe_hash_table_index.h	26;"	d
HASH_TABLE_TYPE	include/container/hash/extendible_hash_table.h	27;"	d
HASH_TABLE_TYPE	include/container/hash/linear_probe_hash_table.h	29;"	d
HEADER_PAGE_ID	include/common/config.h	/^static constexpr int HEADER_PAGE_ID = 0;                                      \/\/ the header page id$/;"	m	namespace:bustub
HEADER_SIZE	include/recovery/log_record.h	/^  static const int HEADER_SIZE = 20;$/;"	m	class:bustub::LogRecord
HSTOREDEBUGLOG_H	include/common/logger.h	25;"	d
Hash	container/hash/extendible_hash_table.cpp	/^uint32_t HASH_TABLE_TYPE::Hash(KeyType key) {$/;"	f	class:bustub::HASH_TABLE_TYPE
HashComparator	include/storage/index/hash_comparator.h	/^class HashComparator {$/;"	c	namespace:bustub
HashFunction	include/container/hash/hash_function.h	/^class HashFunction {$/;"	c	namespace:bustub
HashJoin	include/execution/plans/abstract_plan.h	/^  HashJoin, $/;"	m	class:bustub::PlanType
HashJoinExecutor	execution/hash_join_executor.cpp	/^HashJoinExecutor::HashJoinExecutor(ExecutorContext *exec_ctx, const HashJoinPlanNode *plan,$/;"	f	class:bustub::HashJoinExecutor
HashJoinExecutor	include/execution/executors/hash_join_executor.h	/^class HashJoinExecutor : public AbstractExecutor {$/;"	c	namespace:bustub
HashJoinKey	include/execution/executors/hash_join_executor.h	/^struct HashJoinKey {$/;"	s	namespace:bustub
HashJoinPlanNode	include/execution/plans/hash_join_plan.h	/^  HashJoinPlanNode(const Schema *output_schema, std::vector<const AbstractPlanNode *> &&children,$/;"	f	class:bustub::HashJoinPlanNode
HashJoinPlanNode	include/execution/plans/hash_join_plan.h	/^class HashJoinPlanNode : public AbstractPlanNode {$/;"	c	namespace:bustub
HashTable	include/container/hash/hash_table.h	/^class HashTable {$/;"	c	namespace:bustub
HashTableBlockPage	include/storage/page/hash_table_block_page.h	/^class HashTableBlockPage {$/;"	c	namespace:bustub
HashTableBucketPage	include/storage/page/hash_table_bucket_page.h	/^class HashTableBucketPage {$/;"	c	namespace:bustub
HashTableDirectoryPage	include/storage/page/hash_table_directory_page.h	/^class HashTableDirectoryPage {$/;"	c	namespace:bustub
HashTableHeaderPage	include/storage/page/hash_table_header_page.h	/^class HashTableHeaderPage {$/;"	c	namespace:bustub
HashUtil	include/common/util/hash_util.h	/^class HashUtil {$/;"	c	namespace:bustub
HeaderPage	include/storage/page/header_page.h	/^class HeaderPage : public Page {$/;"	c	namespace:bustub
INCOMPATIBLE_TYPE	include/common/exception.h	/^  INCOMPATIBLE_TYPE = 8,$/;"	m	class:bustub::ExceptionType
INDEXITERATOR_TYPE	include/storage/index/b_plus_tree.h	/^  auto Begin() -> INDEXITERATOR_TYPE;$/;"	m	class:bustub::BPlusTree
INDEXITERATOR_TYPE	include/storage/index/b_plus_tree.h	/^  auto Begin(const KeyType &key) -> INDEXITERATOR_TYPE;$/;"	m	class:bustub::BPlusTree
INDEXITERATOR_TYPE	include/storage/index/b_plus_tree.h	/^  auto End() -> INDEXITERATOR_TYPE;$/;"	m	class:bustub::BPlusTree
INDEXITERATOR_TYPE	include/storage/index/b_plus_tree_index.h	/^  auto GetBeginIterator() -> INDEXITERATOR_TYPE;$/;"	m	class:bustub::BPlusTreeIndex
INDEXITERATOR_TYPE	include/storage/index/b_plus_tree_index.h	/^  auto GetBeginIterator(const KeyType &key) -> INDEXITERATOR_TYPE;$/;"	m	class:bustub::BPlusTreeIndex
INDEXITERATOR_TYPE	include/storage/index/b_plus_tree_index.h	/^  auto GetEndIterator() -> INDEXITERATOR_TYPE;$/;"	m	class:bustub::BPlusTreeIndex
INDEXITERATOR_TYPE	include/storage/index/index_iterator.h	20;"	d
INDEX_TEMPLATE_ARGUMENTS	include/storage/page/b_plus_tree_page.h	25;"	d
INSERT	include/concurrency/transaction.h	/^enum class WType { INSERT = 0, DELETE, UPDATE };$/;"	m	class:bustub::WType
INSERT	include/recovery/log_record.h	/^  INSERT,$/;"	m	class:bustub::LogRecordType
INTEGER	include/type/type_id.h	/^enum TypeId { INVALID = 0, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, VARCHAR, TIMESTAMP };$/;"	e	enum:bustub::TypeId
INTERNAL_PAGE_HEADER_SIZE	include/storage/page/b_plus_tree_internal_page.h	20;"	d
INTERNAL_PAGE_SIZE	include/storage/page/b_plus_tree_internal_page.h	21;"	d
INT_COMPARE_FUNC	type/integer_type.cpp	21;"	d	file:
INT_MODIFY_FUNC	type/integer_type.cpp	41;"	d	file:
INVALID	include/common/exception.h	/^  INVALID = 0,$/;"	m	class:bustub::ExceptionType
INVALID	include/recovery/log_record.h	/^  INVALID = 0,$/;"	m	class:bustub::LogRecordType
INVALID	include/type/type_id.h	/^enum TypeId { INVALID = 0, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, VARCHAR, TIMESTAMP };$/;"	e	enum:bustub::TypeId
INVALID_INDEX_PAGE	include/storage/page/b_plus_tree_page.h	/^enum class IndexPageType { INVALID_INDEX_PAGE = 0, LEAF_PAGE, INTERNAL_PAGE };$/;"	m	class:bustub::IndexPageType
INVALID_LSN	include/common/config.h	/^static constexpr int INVALID_LSN = -1;                                        \/\/ invalid log sequence number$/;"	m	namespace:bustub
INVALID_PAGE_ID	include/common/config.h	/^static constexpr int INVALID_PAGE_ID = -1;                                    \/\/ invalid page id$/;"	m	namespace:bustub
INVALID_TXN_ID	include/common/config.h	/^static constexpr int INVALID_TXN_ID = -1;                                     \/\/ invalid transaction id$/;"	m	namespace:bustub
IncrGlobalDepth	storage/page/hash_table_directory_page.cpp	/^void HashTableDirectoryPage::IncrGlobalDepth() { global_depth_++; }$/;"	f	class:bustub::HashTableDirectoryPage
IncrLocalDepth	storage/page/hash_table_directory_page.cpp	/^void HashTableDirectoryPage::IncrLocalDepth(uint32_t bucket_idx) { local_depths_[bucket_idx]++; }$/;"	f	class:bustub::HashTableDirectoryPage
IncreaseSize	storage/page/b_plus_tree_page.cpp	/^void BPlusTreePage::IncreaseSize(int amount) {}$/;"	f	class:bustub::BPlusTreePage
IncrementPollCount	include/execution/plans/mock_scan_plan.h	/^  void IncrementPollCount() const { poll_count_++; }$/;"	f	class:bustub::MockScanPlanNode
Index	include/storage/index/index.h	/^  explicit Index(std::unique_ptr<IndexMetadata> &&metadata) : metadata_{std::move(metadata)} {}$/;"	f	class:bustub::Index
Index	include/storage/index/index.h	/^class Index {$/;"	c	namespace:bustub
IndexInfo	include/catalog/catalog.h	/^  IndexInfo(Schema key_schema, std::string name, std::unique_ptr<Index> &&index, index_oid_t index_oid,$/;"	f	struct:bustub::IndexInfo
IndexInfo	include/catalog/catalog.h	/^struct IndexInfo {$/;"	s	namespace:bustub
IndexIterator	include/storage/index/index_iterator.h	/^  auto operator++() -> IndexIterator &;$/;"	m	class:bustub::IndexIterator
IndexIterator	include/storage/index/index_iterator.h	/^class IndexIterator {$/;"	c	namespace:bustub
IndexMetadata	include/storage/index/index.h	/^  IndexMetadata(std::string index_name, std::string table_name, const Schema *tuple_schema,$/;"	f	class:bustub::IndexMetadata
IndexMetadata	include/storage/index/index.h	/^class IndexMetadata {$/;"	c	namespace:bustub
IndexPageType	include/storage/page/b_plus_tree_page.h	/^enum class IndexPageType { INVALID_INDEX_PAGE = 0, LEAF_PAGE, INTERNAL_PAGE };$/;"	c	namespace:bustub
IndexScan	include/execution/plans/abstract_plan.h	/^  IndexScan,$/;"	m	class:bustub::PlanType
IndexScanExecutor	execution/index_scan_executor.cpp	/^IndexScanExecutor::IndexScanExecutor(ExecutorContext *exec_ctx, const IndexScanPlanNode *plan)$/;"	f	class:bustub::IndexScanExecutor
IndexScanExecutor	include/execution/executors/index_scan_executor.h	/^class IndexScanExecutor : public AbstractExecutor {$/;"	c	namespace:bustub
IndexScanPlanNode	include/execution/plans/index_scan_plan.h	/^  IndexScanPlanNode(const Schema *output, const AbstractExpression *predicate, index_oid_t index_oid)$/;"	f	class:bustub::IndexScanPlanNode
IndexScanPlanNode	include/execution/plans/index_scan_plan.h	/^class IndexScanPlanNode : public AbstractPlanNode {$/;"	c	namespace:bustub
IndexWriteRecord	include/concurrency/transaction.h	/^  IndexWriteRecord(RID rid, table_oid_t table_oid, WType wtype, const Tuple &tuple, const Tuple &old_tuple,$/;"	f	class:bustub::IndexWriteRecord
IndexWriteRecord	include/concurrency/transaction.h	/^class IndexWriteRecord {$/;"	c	namespace:bustub
Init	execution/aggregation_executor.cpp	/^void AggregationExecutor::Init() {$/;"	f	class:bustub::AggregationExecutor
Init	execution/delete_executor.cpp	/^void DeleteExecutor::Init() { child_executor_->Init(); }$/;"	f	class:bustub::DeleteExecutor
Init	execution/distinct_executor.cpp	/^void DistinctExecutor::Init() {$/;"	f	class:bustub::DistinctExecutor
Init	execution/hash_join_executor.cpp	/^void HashJoinExecutor::Init() {$/;"	f	class:bustub::HashJoinExecutor
Init	execution/index_scan_executor.cpp	/^void IndexScanExecutor::Init() {}$/;"	f	class:bustub::IndexScanExecutor
Init	execution/insert_executor.cpp	/^void InsertExecutor::Init() {$/;"	f	class:bustub::InsertExecutor
Init	execution/limit_executor.cpp	/^void LimitExecutor::Init() {$/;"	f	class:bustub::LimitExecutor
Init	execution/mock_scan_executor.cpp	/^void MockScanExecutor::Init() {$/;"	f	class:bustub::MockScanExecutor
Init	execution/nested_index_join_executor.cpp	/^void NestIndexJoinExecutor::Init() {}$/;"	f	class:bustub::NestIndexJoinExecutor
Init	execution/nested_loop_join_executor.cpp	/^void NestedLoopJoinExecutor::Init() {$/;"	f	class:bustub::NestedLoopJoinExecutor
Init	execution/seq_scan_executor.cpp	/^void SeqScanExecutor::Init() {$/;"	f	class:bustub::SeqScanExecutor
Init	execution/update_executor.cpp	/^void UpdateExecutor::Init() { child_executor_->Init(); }$/;"	f	class:bustub::UpdateExecutor
Init	include/storage/page/header_page.h	/^  void Init() { SetRecordCount(0); }$/;"	f	class:bustub::HeaderPage
Init	include/storage/page/tmp_tuple_page.h	/^  void Init(page_id_t page_id, uint32_t page_size) {$/;"	f	class:bustub::TmpTuplePage
Init	storage/page/b_plus_tree_internal_page.cpp	/^void B_PLUS_TREE_INTERNAL_PAGE_TYPE::Init(page_id_t page_id, page_id_t parent_id, int max_size) {}$/;"	f	class:bustub::B_PLUS_TREE_INTERNAL_PAGE_TYPE
Init	storage/page/b_plus_tree_leaf_page.cpp	/^void B_PLUS_TREE_LEAF_PAGE_TYPE::Init(page_id_t page_id, page_id_t parent_id, int max_size) {}$/;"	f	class:bustub::B_PLUS_TREE_LEAF_PAGE_TYPE
Init	storage/page/table_page.cpp	/^void TablePage::Init(page_id_t page_id, uint32_t page_size, page_id_t prev_page_id, LogManager *log_manager,$/;"	f	class:bustub::TablePage
Insert	container/hash/extendible_hash_table.cpp	/^bool HASH_TABLE_TYPE::Insert(Transaction *transaction, const KeyType &key, const ValueType &value) {$/;"	f	class:bustub::HASH_TABLE_TYPE
Insert	include/execution/plans/abstract_plan.h	/^  Insert,$/;"	m	class:bustub::PlanType
Insert	storage/page/hash_table_bucket_page.cpp	/^bool HASH_TABLE_BUCKET_TYPE::Insert(KeyType key, ValueType value, KeyComparator cmp) {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
InsertCombine	include/execution/executors/aggregation_executor.h	/^  void InsertCombine(const AggregateKey &agg_key, const AggregateValue &agg_val) {$/;"	f	class:bustub::SimpleAggregationHashTable
InsertEntry	storage/index/b_plus_tree_index.cpp	/^void BPLUSTREE_INDEX_TYPE::InsertEntry(const Tuple &key, RID rid, Transaction *transaction) {$/;"	f	class:bustub::BPLUSTREE_INDEX_TYPE
InsertEntry	storage/index/extendible_hash_table_index.cpp	/^void HASH_TABLE_INDEX_TYPE::InsertEntry(const Tuple &key, RID rid, Transaction *transaction) {$/;"	f	class:bustub::HASH_TABLE_INDEX_TYPE
InsertEntry	storage/index/linear_probe_hash_table_index.cpp	/^void HASH_TABLE_INDEX_TYPE::InsertEntry(const Tuple &key, RID rid, Transaction *transaction) {$/;"	f	class:bustub::HASH_TABLE_INDEX_TYPE
InsertExecutor	execution/insert_executor.cpp	/^InsertExecutor::InsertExecutor(ExecutorContext *exec_ctx, const InsertPlanNode *plan,$/;"	f	class:bustub::InsertExecutor
InsertExecutor	include/execution/executors/insert_executor.h	/^class InsertExecutor : public AbstractExecutor {$/;"	c	namespace:bustub
InsertFromFile	storage/index/b_plus_tree.cpp	/^void BPLUSTREE_TYPE::InsertFromFile(const std::string &file_name, Transaction *transaction) {$/;"	f	class:bustub::BPLUSTREE_TYPE
InsertIntoParent	storage/index/b_plus_tree.cpp	/^void BPLUSTREE_TYPE::InsertIntoParent(BPlusTreePage *old_node, const KeyType &key, BPlusTreePage *new_node,$/;"	f	class:bustub::BPLUSTREE_TYPE
InsertPlanNode	include/execution/plans/insert_plan.h	/^  InsertPlanNode(const AbstractPlanNode *child, table_oid_t table_oid)$/;"	f	class:bustub::InsertPlanNode
InsertPlanNode	include/execution/plans/insert_plan.h	/^  InsertPlanNode(std::vector<std::vector<Value>> &&raw_values, table_oid_t table_oid)$/;"	f	class:bustub::InsertPlanNode
InsertPlanNode	include/execution/plans/insert_plan.h	/^class InsertPlanNode : public AbstractPlanNode {$/;"	c	namespace:bustub
IntComparator	include/storage/index/int_comparator.h	/^class IntComparator {$/;"	c	namespace:bustub
IntegerParentType	include/type/integer_parent_type.h	/^class IntegerParentType : public NumericType {$/;"	c	namespace:bustub
IntegerParentType	type/integer_parent_type.cpp	/^IntegerParentType::IntegerParentType(TypeId type) : NumericType(type) {}$/;"	f	class:bustub::IntegerParentType
IntegerType	include/type/integer_type.h	/^class IntegerType : public IntegerParentType {$/;"	c	namespace:bustub
IntegerType	type/integer_type.cpp	/^IntegerType::IntegerType(TypeId type) : IntegerParentType(type) {}$/;"	f	class:bustub::IntegerType
IsEmpty	storage/page/hash_table_bucket_page.cpp	/^bool HASH_TABLE_BUCKET_TYPE::IsEmpty() {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
IsFull	storage/page/hash_table_bucket_page.cpp	/^bool HASH_TABLE_BUCKET_TYPE::IsFull() {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
IsOccupied	storage/page/hash_table_bucket_page.cpp	/^bool HASH_TABLE_BUCKET_TYPE::IsOccupied(uint32_t bucket_idx) const {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
IsReadable	storage/page/hash_table_bucket_page.cpp	/^bool HASH_TABLE_BUCKET_TYPE::IsReadable(uint32_t bucket_idx) const {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
IsolationLevel	include/concurrency/transaction.h	/^enum class IsolationLevel { READ_UNCOMMITTED, REPEATABLE_READ, READ_COMMITTED };$/;"	c	namespace:bustub
Iterator	include/execution/executors/aggregation_executor.h	/^    explicit Iterator(std::unordered_map<AggregateKey, AggregateValue>::const_iterator iter) : iter_{iter} {}$/;"	f	class:bustub::SimpleAggregationHashTable::Iterator
Iterator	include/execution/executors/aggregation_executor.h	/^  class Iterator {$/;"	c	class:bustub::SimpleAggregationHashTable
K_USECS_PER_DATE	include/type/timestamp_type.h	/^  static constexpr uint64_t K_USECS_PER_DATE = 86400000000UL;$/;"	m	class:bustub::TimestampType
Key	include/execution/executors/aggregation_executor.h	/^    const AggregateKey &Key() { return iter_->first; }$/;"	f	class:bustub::SimpleAggregationHashTable::Iterator
KeyAt	storage/page/hash_table_bucket_page.cpp	/^KeyType HASH_TABLE_BUCKET_TYPE::KeyAt(uint32_t bucket_idx) const {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
KeyToDirectoryIndex	container/hash/extendible_hash_table.cpp	/^uint32_t HASH_TABLE_TYPE::KeyToDirectoryIndex(KeyType key, HashTableDirectoryPage *dir_page) {$/;"	f	class:bustub::HASH_TABLE_TYPE
KeyToPageId	container/hash/extendible_hash_table.cpp	/^page_id_t HASH_TABLE_TYPE::KeyToPageId(KeyType key, HashTableDirectoryPage *dir_page) {$/;"	f	class:bustub::HASH_TABLE_TYPE
KeyType	include/storage/page/b_plus_tree_internal_page.h	/^  auto KeyAt(int index) const -> KeyType;$/;"	m	class:bustub::BPlusTreeInternalPage
KeyType	include/storage/page/b_plus_tree_leaf_page.h	/^  auto KeyAt(int index) const -> KeyType;$/;"	m	class:bustub::BPlusTreeLeafPage
KeyType	include/storage/page/hash_table_block_page.h	/^  auto KeyAt(slot_offset_t bucket_ind) const -> KeyType;$/;"	m	class:bustub::HashTableBlockPage
LEAF_PAGE	include/storage/page/b_plus_tree_page.h	/^enum class IndexPageType { INVALID_INDEX_PAGE = 0, LEAF_PAGE, INTERNAL_PAGE };$/;"	m	class:bustub::IndexPageType
LEAF_PAGE_HEADER_SIZE	include/storage/page/b_plus_tree_leaf_page.h	21;"	d
LEAF_PAGE_SIZE	include/storage/page/b_plus_tree_leaf_page.h	22;"	d
LOCK_ON_SHRINKING	include/concurrency/transaction.h	/^  LOCK_ON_SHRINKING,$/;"	m	class:bustub::AbortReason
LOG_BUFFER_SIZE	include/common/config.h	/^static constexpr int LOG_BUFFER_SIZE = ((BUFFER_POOL_SIZE + 1) * PAGE_SIZE);  \/\/ size of a log buffer in byte$/;"	m	namespace:bustub
LOG_DEBUG	include/common/logger.h	146;"	d
LOG_DEBUG	include/common/logger.h	152;"	d
LOG_DEBUG_ENABLED	include/common/logger.h	141;"	d
LOG_DEBUG_ENABLED	include/common/logger.h	144;"	d
LOG_ERROR	include/common/logger.h	101;"	d
LOG_ERROR	include/common/logger.h	107;"	d
LOG_ERROR_ENABLED	include/common/logger.h	96;"	d
LOG_ERROR_ENABLED	include/common/logger.h	99;"	d
LOG_INFO	include/common/logger.h	131;"	d
LOG_INFO	include/common/logger.h	137;"	d
LOG_INFO_ENABLED	include/common/logger.h	126;"	d
LOG_INFO_ENABLED	include/common/logger.h	129;"	d
LOG_LEVEL	include/common/logger.h	/^static constexpr int LOG_LEVEL = LOG_LEVEL_DEBUG;$/;"	m	namespace:bustub
LOG_LEVEL	include/common/logger.h	/^static constexpr int LOG_LEVEL = LOG_LEVEL_INFO;$/;"	m	namespace:bustub
LOG_LEVEL_ALL	include/common/logger.h	/^static constexpr int LOG_LEVEL_ALL = 0;$/;"	m	namespace:bustub
LOG_LEVEL_DEBUG	include/common/logger.h	/^static constexpr int LOG_LEVEL_DEBUG = 200;$/;"	m	namespace:bustub
LOG_LEVEL_ERROR	include/common/logger.h	/^static constexpr int LOG_LEVEL_ERROR = 500;$/;"	m	namespace:bustub
LOG_LEVEL_INFO	include/common/logger.h	/^static constexpr int LOG_LEVEL_INFO = 300;$/;"	m	namespace:bustub
LOG_LEVEL_OFF	include/common/logger.h	/^static constexpr int LOG_LEVEL_OFF = 1000;$/;"	m	namespace:bustub
LOG_LEVEL_TRACE	include/common/logger.h	/^static constexpr int LOG_LEVEL_TRACE = 100;$/;"	m	namespace:bustub
LOG_LEVEL_WARN	include/common/logger.h	/^static constexpr int LOG_LEVEL_WARN = 400;$/;"	m	namespace:bustub
LOG_LOG_TIME_FORMAT	include/common/logger.h	65;"	d
LOG_OUTPUT_STREAM	include/common/logger.h	66;"	d
LOG_TRACE	include/common/logger.h	161;"	d
LOG_TRACE	include/common/logger.h	167;"	d
LOG_TRACE_ENABLED	include/common/logger.h	156;"	d
LOG_TRACE_ENABLED	include/common/logger.h	159;"	d
LOG_WARN	include/common/logger.h	116;"	d
LOG_WARN	include/common/logger.h	122;"	d
LOG_WARN_ENABLED	include/common/logger.h	111;"	d
LOG_WARN_ENABLED	include/common/logger.h	114;"	d
LRUReplacer	buffer/lru_replacer.cpp	/^LRUReplacer::LRUReplacer(size_t num_pages) {}$/;"	f	class:bustub::LRUReplacer
LRUReplacer	include/buffer/lru_replacer.h	/^class LRUReplacer : public Replacer {$/;"	c	namespace:bustub
LessThan	include/execution/expressions/comparison_expression.h	/^enum class ComparisonType { Equal, NotEqual, LessThan, LessThanOrEqual, GreaterThan, GreaterThanOrEqual };$/;"	m	class:bustub::ComparisonType
LessThanOrEqual	include/execution/expressions/comparison_expression.h	/^enum class ComparisonType { Equal, NotEqual, LessThan, LessThanOrEqual, GreaterThan, GreaterThanOrEqual };$/;"	m	class:bustub::ComparisonType
Limit	include/execution/plans/abstract_plan.h	/^  Limit,$/;"	m	class:bustub::PlanType
LimitExecutor	execution/limit_executor.cpp	/^LimitExecutor::LimitExecutor(ExecutorContext *exec_ctx, const LimitPlanNode *plan,$/;"	f	class:bustub::LimitExecutor
LimitExecutor	include/execution/executors/limit_executor.h	/^class LimitExecutor : public AbstractExecutor {$/;"	c	namespace:bustub
LimitPlanNode	include/execution/plans/limit_plan.h	/^  LimitPlanNode(const Schema *output_schema, const AbstractPlanNode *child, std::size_t limit)$/;"	f	class:bustub::LimitPlanNode
LimitPlanNode	include/execution/plans/limit_plan.h	/^class LimitPlanNode : public AbstractPlanNode {$/;"	c	namespace:bustub
LinearProbeHashTable	container/hash/linear_probe_hash_table.cpp	/^HASH_TABLE_TYPE::LinearProbeHashTable(const std::string &name, BufferPoolManager *buffer_pool_manager,$/;"	f	class:bustub::HASH_TABLE_TYPE
LinearProbeHashTable	include/container/hash/linear_probe_hash_table.h	/^class LinearProbeHashTable : public HashTable<KeyType, ValueType, KeyComparator> {$/;"	c	namespace:bustub
LinearProbeHashTableIndex	include/storage/index/linear_probe_hash_table_index.h	/^class LinearProbeHashTableIndex : public Index {$/;"	c	namespace:bustub
LinearProbeHashTableIndex	storage/index/linear_probe_hash_table_index.cpp	/^HASH_TABLE_INDEX_TYPE::LinearProbeHashTableIndex(std::unique_ptr<IndexMetadata> &&metadata,$/;"	f	class:bustub::HASH_TABLE_INDEX_TYPE
LinkListNode	include/buffer/lru_replacer.h	/^  explicit LinkListNode(frame_id_t Val) : val_(Val), prev_(nullptr), next_(nullptr) {}$/;"	f	class:bustub::LinkListNode
LinkListNode	include/buffer/lru_replacer.h	/^class LinkListNode {$/;"	c	namespace:bustub
LockManager	include/concurrency/lock_manager.h	/^class LockManager {$/;"	c	namespace:bustub
LockMode	include/concurrency/lock_manager.h	/^  enum class LockMode { SHARED, EXCLUSIVE };$/;"	c	class:bustub::LockManager
LockRequest	include/concurrency/lock_manager.h	/^    LockRequest(txn_id_t txn_id, LockMode lock_mode) : txn_id_(txn_id), lock_mode_(lock_mode), granted_(false) {}$/;"	f	class:bustub::LockManager::LockRequest
LockRequest	include/concurrency/lock_manager.h	/^  class LockRequest {$/;"	c	class:bustub::LockManager
LockRequestQueue	include/concurrency/lock_manager.h	/^  class LockRequestQueue {$/;"	c	class:bustub::LockManager
LogManager	include/recovery/log_manager.h	/^  explicit LogManager(DiskManager *disk_manager)$/;"	f	class:bustub::LogManager
LogManager	include/recovery/log_manager.h	/^class LogManager {$/;"	c	namespace:bustub
LogRecord	include/recovery/log_record.h	/^  LogRecord(txn_id_t txn_id, lsn_t prev_lsn, LogRecordType log_record_type)$/;"	f	class:bustub::LogRecord
LogRecord	include/recovery/log_record.h	/^  LogRecord(txn_id_t txn_id, lsn_t prev_lsn, LogRecordType log_record_type, const RID &rid, const Tuple &tuple)$/;"	f	class:bustub::LogRecord
LogRecord	include/recovery/log_record.h	/^  LogRecord(txn_id_t txn_id, lsn_t prev_lsn, LogRecordType log_record_type, const RID &update_rid,$/;"	f	class:bustub::LogRecord
LogRecord	include/recovery/log_record.h	/^  LogRecord(txn_id_t txn_id, lsn_t prev_lsn, LogRecordType log_record_type, page_id_t prev_page_id, page_id_t page_id)$/;"	f	class:bustub::LogRecord
LogRecord	include/recovery/log_record.h	/^class LogRecord {$/;"	c	namespace:bustub
LogRecordType	include/recovery/log_record.h	/^enum class LogRecordType {$/;"	c	namespace:bustub
LogRecovery	include/recovery/log_recovery.h	/^  LogRecovery(DiskManager *disk_manager, BufferPoolManager *buffer_pool_manager)$/;"	f	class:bustub::LogRecovery
LogRecovery	include/recovery/log_recovery.h	/^class LogRecovery {$/;"	c	namespace:bustub
MARKDELETE	include/recovery/log_record.h	/^  MARKDELETE,$/;"	m	class:bustub::LogRecordType
MAX_READERS	include/common/rwlatch.h	/^  static const uint32_t MAX_READERS = UINT_MAX;$/;"	m	class:bustub::ReaderWriterLatch
MISMATCH_TYPE	include/common/exception.h	/^  MISMATCH_TYPE = 5,$/;"	m	class:bustub::ExceptionType
MakeAggregateKey	include/execution/executors/aggregation_executor.h	/^  AggregateKey MakeAggregateKey(const Tuple *tuple) {$/;"	f	class:bustub::AggregationExecutor
MakeAggregateValue	include/execution/executors/aggregation_executor.h	/^  AggregateValue MakeAggregateValue(const Tuple *tuple) {$/;"	f	class:bustub::AggregationExecutor
MakeDummyRID	execution/mock_scan_executor.cpp	/^RID MockScanExecutor::MakeDummyRID() const { return RID{0}; }$/;"	f	class:bustub::MockScanExecutor
MakeDummyTuple	execution/mock_scan_executor.cpp	/^Tuple MockScanExecutor::MakeDummyTuple() const {$/;"	f	class:bustub::MockScanExecutor
MakeKey	include/execution/executors/distinct_executor.h	/^  DistinctKey MakeKey(const Tuple *tuple) {$/;"	f	class:bustub::DistinctExecutor
MappingType	include/storage/index/index_iterator.h	/^  auto operator*() -> const MappingType &;$/;"	m	class:bustub::IndexIterator
MappingType	include/storage/page/b_plus_tree_leaf_page.h	/^  auto GetItem(int index) -> const MappingType &;$/;"	m	class:bustub::BPlusTreeLeafPage
MappingType	include/storage/page/b_plus_tree_page.h	23;"	d
MappingType	include/storage/page/hash_table_page_defs.h	15;"	d
Matrix	include/primer/p0_starter.h	/^  Matrix(int rows, int cols) : rows_(rows), cols_(cols) { linear_ = new T[rows * cols + 1]; }$/;"	f	class:bustub::Matrix
Matrix	include/primer/p0_starter.h	/^class Matrix {$/;"	c	namespace:bustub
Merge	container/hash/extendible_hash_table.cpp	/^void HASH_TABLE_TYPE::Merge(Transaction *transaction, const KeyType &key, const ValueType &value) {$/;"	f	class:bustub::HASH_TABLE_TYPE
MinAggregate	include/execution/plans/aggregation_plan.h	/^enum class AggregationType { CountAggregate, SumAggregate, MinAggregate, MaxAggregate };$/;"	m	class:bustub::AggregationType
MockScanExecutor	execution/mock_scan_executor.cpp	/^MockScanExecutor::MockScanExecutor(ExecutorContext *exec_ctx, const MockScanPlanNode *plan)$/;"	f	class:bustub::MockScanExecutor
MockScanExecutor	include/execution/executors/mock_scan_executor.h	/^class MockScanExecutor : public AbstractExecutor {$/;"	c	namespace:bustub
MockScanPlanNode	include/execution/plans/mock_scan_plan.h	/^  MockScanPlanNode(const Schema *output, std::size_t size)$/;"	f	class:bustub::MockScanPlanNode
MockScanPlanNode	include/execution/plans/mock_scan_plan.h	/^class MockScanPlanNode : public AbstractPlanNode {$/;"	c	namespace:bustub
MoveAllTo	storage/page/b_plus_tree_internal_page.cpp	/^void B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveAllTo(BPlusTreeInternalPage *recipient, const KeyType &middle_key,$/;"	f	class:bustub::B_PLUS_TREE_INTERNAL_PAGE_TYPE
MoveAllTo	storage/page/b_plus_tree_leaf_page.cpp	/^void B_PLUS_TREE_LEAF_PAGE_TYPE::MoveAllTo(BPlusTreeLeafPage *recipient) {}$/;"	f	class:bustub::B_PLUS_TREE_LEAF_PAGE_TYPE
MoveFirstToEndOf	storage/page/b_plus_tree_internal_page.cpp	/^void B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveFirstToEndOf(BPlusTreeInternalPage *recipient, const KeyType &middle_key,$/;"	f	class:bustub::B_PLUS_TREE_INTERNAL_PAGE_TYPE
MoveFirstToEndOf	storage/page/b_plus_tree_leaf_page.cpp	/^void B_PLUS_TREE_LEAF_PAGE_TYPE::MoveFirstToEndOf(BPlusTreeLeafPage *recipient) {}$/;"	f	class:bustub::B_PLUS_TREE_LEAF_PAGE_TYPE
MoveHalfTo	storage/page/b_plus_tree_internal_page.cpp	/^void B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveHalfTo(BPlusTreeInternalPage *recipient,$/;"	f	class:bustub::B_PLUS_TREE_INTERNAL_PAGE_TYPE
MoveHalfTo	storage/page/b_plus_tree_leaf_page.cpp	/^void B_PLUS_TREE_LEAF_PAGE_TYPE::MoveHalfTo(BPlusTreeLeafPage *recipient) {}$/;"	f	class:bustub::B_PLUS_TREE_LEAF_PAGE_TYPE
MoveLastToFrontOf	storage/page/b_plus_tree_internal_page.cpp	/^void B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveLastToFrontOf(BPlusTreeInternalPage *recipient, const KeyType &middle_key,$/;"	f	class:bustub::B_PLUS_TREE_INTERNAL_PAGE_TYPE
MoveLastToFrontOf	storage/page/b_plus_tree_leaf_page.cpp	/^void B_PLUS_TREE_LEAF_PAGE_TYPE::MoveLastToFrontOf(BPlusTreeLeafPage *recipient) {}$/;"	f	class:bustub::B_PLUS_TREE_LEAF_PAGE_TYPE
Multiply	include/primer/p0_starter.h	/^  static std::unique_ptr<RowMatrix<T>> Multiply(const RowMatrix<T> *matrixA, const RowMatrix<T> *matrixB) {$/;"	f	class:bustub::RowMatrixOperations
N	include/storage/index/b_plus_tree.h	/^  auto Split(N *node) -> N *;$/;"	m	class:bustub::BPlusTree
NEWPAGE	include/recovery/log_record.h	/^  NEWPAGE,$/;"	m	class:bustub::LogRecordType
NOT_IMPLEMENTED	include/common/exception.h	/^  NOT_IMPLEMENTED = 11,$/;"	m	class:bustub::ExceptionType
NestIndexJoinExecutor	execution/nested_index_join_executor.cpp	/^NestIndexJoinExecutor::NestIndexJoinExecutor(ExecutorContext *exec_ctx, const NestedIndexJoinPlanNode *plan,$/;"	f	class:bustub::NestIndexJoinExecutor
NestIndexJoinExecutor	include/execution/executors/nested_index_join_executor.h	/^class NestIndexJoinExecutor : public AbstractExecutor {$/;"	c	namespace:bustub
NestedIndexJoin	include/execution/plans/abstract_plan.h	/^  NestedIndexJoin,$/;"	m	class:bustub::PlanType
NestedIndexJoinPlanNode	include/execution/plans/nested_index_join_plan.h	/^  NestedIndexJoinPlanNode(const Schema *output_schema, std::vector<const AbstractPlanNode *> &&children,$/;"	f	class:bustub::NestedIndexJoinPlanNode
NestedIndexJoinPlanNode	include/execution/plans/nested_index_join_plan.h	/^class NestedIndexJoinPlanNode : public AbstractPlanNode {$/;"	c	namespace:bustub
NestedLoopJoin	include/execution/plans/abstract_plan.h	/^  NestedLoopJoin,$/;"	m	class:bustub::PlanType
NestedLoopJoinExecutor	execution/nested_loop_join_executor.cpp	/^NestedLoopJoinExecutor::NestedLoopJoinExecutor(ExecutorContext *exec_ctx, const NestedLoopJoinPlanNode *plan,$/;"	f	class:bustub::NestedLoopJoinExecutor
NestedLoopJoinExecutor	include/execution/executors/nested_loop_join_executor.h	/^class NestedLoopJoinExecutor : public AbstractExecutor {$/;"	c	namespace:bustub
NestedLoopJoinPlanNode	include/execution/plans/nested_loop_join_plan.h	/^  NestedLoopJoinPlanNode(const Schema *output_schema, std::vector<const AbstractPlanNode *> &&children,$/;"	f	class:bustub::NestedLoopJoinPlanNode
NestedLoopJoinPlanNode	include/execution/plans/nested_loop_join_plan.h	/^class NestedLoopJoinPlanNode : public AbstractPlanNode {$/;"	c	namespace:bustub
NewPgImp	buffer/buffer_pool_manager_instance.cpp	/^Page *BufferPoolManagerInstance::NewPgImp(page_id_t *page_id) {$/;"	f	class:bustub::BufferPoolManagerInstance
Next	execution/aggregation_executor.cpp	/^bool AggregationExecutor::Next(Tuple *tuple, RID *rid) {$/;"	f	class:bustub::AggregationExecutor
Next	execution/delete_executor.cpp	/^bool DeleteExecutor::Next([[maybe_unused]] Tuple *tuple, RID *rid) {$/;"	f	class:bustub::DeleteExecutor
Next	execution/distinct_executor.cpp	/^bool DistinctExecutor::Next(Tuple *tuple, RID *rid) {$/;"	f	class:bustub::DistinctExecutor
Next	execution/hash_join_executor.cpp	/^bool HashJoinExecutor::Next(Tuple *tuple, RID *rid) {$/;"	f	class:bustub::HashJoinExecutor
Next	execution/insert_executor.cpp	/^bool InsertExecutor::Next([[maybe_unused]] Tuple *tuple, RID *rid) {$/;"	f	class:bustub::InsertExecutor
Next	execution/limit_executor.cpp	/^bool LimitExecutor::Next(Tuple *tuple, RID *rid) {$/;"	f	class:bustub::LimitExecutor
Next	execution/mock_scan_executor.cpp	/^bool MockScanExecutor::Next(Tuple *tuple, RID *rid) {$/;"	f	class:bustub::MockScanExecutor
Next	execution/nested_loop_join_executor.cpp	/^bool NestedLoopJoinExecutor::Next(Tuple *tuple, RID *rid) {$/;"	f	class:bustub::NestedLoopJoinExecutor
Next	execution/seq_scan_executor.cpp	/^bool SeqScanExecutor::Next(Tuple *tuple, RID *rid) {$/;"	f	class:bustub::SeqScanExecutor
Next	execution/update_executor.cpp	/^bool UpdateExecutor::Next([[maybe_unused]] Tuple *tuple, RID *rid) {$/;"	f	class:bustub::UpdateExecutor
NotEqual	include/execution/expressions/comparison_expression.h	/^enum class ComparisonType { Equal, NotEqual, LessThan, LessThanOrEqual, GreaterThan, GreaterThanOrEqual };$/;"	m	class:bustub::ComparisonType
NotImplementedException	include/common/exception.h	/^  explicit NotImplementedException(const std::string &msg) : Exception(ExceptionType::NOT_IMPLEMENTED, msg) {}$/;"	f	class:bustub::NotImplementedException
NotImplementedException	include/common/exception.h	/^class NotImplementedException : public Exception {$/;"	c	namespace:bustub
NumReadable	storage/page/hash_table_bucket_page.cpp	/^uint32_t HASH_TABLE_BUCKET_TYPE::NumReadable() {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
NumericType	include/type/numeric_type.h	/^  explicit NumericType(TypeId type) : Type(type) {}$/;"	f	class:bustub::NumericType
NumericType	include/type/numeric_type.h	/^class NumericType : public Type {$/;"	c	namespace:bustub
OBJECTLENGTH_NULL	include/type/limits.h	/^static constexpr int OBJECTLENGTH_NULL = -1;$/;"	m	namespace:bustub
OFFSET_FREE_SPACE	include/storage/page/table_page.h	/^  static constexpr size_t OFFSET_FREE_SPACE = 16;$/;"	m	class:bustub::TablePage
OFFSET_LSN	include/storage/page/page.h	/^  static constexpr size_t OFFSET_LSN = 4;$/;"	m	class:bustub::Page
OFFSET_NEXT_PAGE_ID	include/storage/page/table_page.h	/^  static constexpr size_t OFFSET_NEXT_PAGE_ID = 12;$/;"	m	class:bustub::TablePage
OFFSET_PAGE_START	include/storage/page/page.h	/^  static constexpr size_t OFFSET_PAGE_START = 0;$/;"	m	class:bustub::Page
OFFSET_PREV_PAGE_ID	include/storage/page/table_page.h	/^  static constexpr size_t OFFSET_PREV_PAGE_ID = 8;$/;"	m	class:bustub::TablePage
OFFSET_TUPLE_COUNT	include/storage/page/table_page.h	/^  static constexpr size_t OFFSET_TUPLE_COUNT = 20;$/;"	m	class:bustub::TablePage
OFFSET_TUPLE_OFFSET	include/storage/page/table_page.h	/^  static constexpr size_t OFFSET_TUPLE_OFFSET = 24;  \/\/ Naming things is hard.$/;"	m	class:bustub::TablePage
OFFSET_TUPLE_SIZE	include/storage/page/table_page.h	/^  static constexpr size_t OFFSET_TUPLE_SIZE = 28;$/;"	m	class:bustub::TablePage
OUT_OF_MEMORY	include/common/exception.h	/^  OUT_OF_MEMORY = 9,$/;"	m	class:bustub::ExceptionType
OUT_OF_RANGE	include/common/exception.h	/^  OUT_OF_RANGE = 1,$/;"	m	class:bustub::ExceptionType
OutputLogHeader	include/common/logger.h	/^inline void OutputLogHeader(const char *file, int line, const char *func, int level) {$/;"	f	namespace:bustub
OutputSchema	include/execution/plans/abstract_plan.h	/^  const Schema *OutputSchema() const { return output_schema_; }$/;"	f	class:bustub::AbstractPlanNode
PAGE_SIZE	include/common/config.h	/^static constexpr int PAGE_SIZE = 4096;                                        \/\/ size of a data page in byte$/;"	m	namespace:bustub
PRIME_FACTOR	include/common/util/hash_util.h	/^  static const hash_t PRIME_FACTOR = 10000019;$/;"	m	class:bustub::HashUtil
Page	include/buffer/buffer_pool_manager.h	/^  virtual auto FetchPgImp(page_id_t page_id) -> Page * = 0;$/;"	m	class:bustub::BufferPoolManager
Page	include/buffer/buffer_pool_manager.h	/^  virtual auto NewPgImp(page_id_t *page_id) -> Page * = 0;$/;"	m	class:bustub::BufferPoolManager
Page	include/storage/index/b_plus_tree.h	/^  auto FindLeafPage(const KeyType &key, bool leftMost = false) -> Page *;$/;"	m	class:bustub::BPlusTree
Page	include/storage/page/page.h	/^  Page() { ResetMemory(); }$/;"	f	class:bustub::Page
Page	include/storage/page/page.h	/^class Page {$/;"	c	namespace:bustub
ParallelBufferPoolManager	buffer/parallel_buffer_pool_manager.cpp	/^ParallelBufferPoolManager::ParallelBufferPoolManager(size_t num_instances, size_t pool_size, DiskManager *disk_manager,$/;"	f	class:bustub::ParallelBufferPoolManager
ParallelBufferPoolManager	include/buffer/parallel_buffer_pool_manager.h	/^class ParallelBufferPoolManager : public BufferPoolManager {$/;"	c	namespace:bustub
Pin	buffer/clock_replacer.cpp	/^void ClockReplacer::Pin(frame_id_t frame_id) {}$/;"	f	class:bustub::ClockReplacer
Pin	buffer/lru_replacer.cpp	/^void LRUReplacer::Pin(frame_id_t frame_id) {$/;"	f	class:bustub::LRUReplacer
PlanType	include/execution/plans/abstract_plan.h	/^enum class PlanType {$/;"	c	namespace:bustub
PollCount	include/execution/plans/mock_scan_plan.h	/^  std::size_t PollCount() const { return poll_count_; }$/;"	f	class:bustub::MockScanPlanNode
PopulateNewRoot	storage/page/b_plus_tree_internal_page.cpp	/^void B_PLUS_TREE_INTERNAL_PAGE_TYPE::PopulateNewRoot(const ValueType &old_value, const KeyType &new_key,$/;"	f	class:bustub::B_PLUS_TREE_INTERNAL_PAGE_TYPE
Print	storage/index/b_plus_tree.cpp	/^void BPLUSTREE_TYPE::Print(BufferPoolManager *bpm) {$/;"	f	class:bustub::BPLUSTREE_TYPE
PrintBucket	storage/page/hash_table_bucket_page.cpp	/^void HASH_TABLE_BUCKET_TYPE::PrintBucket() {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
PrintDirectory	storage/page/hash_table_directory_page.cpp	/^void HashTableDirectoryPage::PrintDirectory() {$/;"	f	class:bustub::HashTableDirectoryPage
READ_UNCOMMITTED	include/concurrency/transaction.h	/^enum class IsolationLevel { READ_UNCOMMITTED, REPEATABLE_READ, READ_COMMITTED };$/;"	m	class:bustub::IsolationLevel
REPEATABLE_READ	include/concurrency/transaction.h	/^enum class IsolationLevel { READ_UNCOMMITTED, REPEATABLE_READ, READ_COMMITTED };$/;"	m	class:bustub::IsolationLevel
RID	include/common/rid.h	/^  RID(page_id_t page_id, uint32_t slot_num) : page_id_(page_id), slot_num_(slot_num) {}$/;"	f	class:bustub::RID
RID	include/common/rid.h	/^  explicit RID(int64_t rid) : page_id_(static_cast<page_id_t>(rid >> 32)), slot_num_(static_cast<uint32_t>(rid)) {}$/;"	f	class:bustub::RID
RID	include/common/rid.h	/^class RID {$/;"	c	namespace:bustub
RLatch	include/storage/page/page.h	/^  inline void RLatch() { rwlatch_.RLock(); }$/;"	f	class:bustub::Page
RLock	include/common/rwlatch.h	/^  void RLock() {$/;"	f	class:bustub::ReaderWriterLatch
ROLLBACKDELETE	include/recovery/log_record.h	/^  ROLLBACKDELETE,$/;"	m	class:bustub::LogRecordType
RTrim	common/util/string_util.cpp	/^void StringUtil::RTrim(std::string *str) {$/;"	f	class:bustub::StringUtil
RUnlatch	include/storage/page/page.h	/^  inline void RUnlatch() { rwlatch_.RUnlock(); }$/;"	f	class:bustub::Page
RUnlock	include/common/rwlatch.h	/^  void RUnlock() {$/;"	f	class:bustub::ReaderWriterLatch
ReadPage	storage/disk/disk_manager.cpp	/^void DiskManager::ReadPage(page_id_t page_id, char *page_data) {$/;"	f	class:bustub::DiskManager
ReaderWriterLatch	include/common/rwlatch.h	/^class ReaderWriterLatch {$/;"	c	namespace:bustub
Redistribute	storage/index/b_plus_tree.cpp	/^void BPLUSTREE_TYPE::Redistribute(N *neighbor_node, N *node, int index) {}$/;"	f	class:bustub::BPLUSTREE_TYPE
Redo	recovery/log_recovery.cpp	/^void LogRecovery::Redo() {}$/;"	f	class:bustub::LogRecovery
ReleaseLocks	include/concurrency/transaction_manager.h	/^  void ReleaseLocks(Transaction *txn) {$/;"	f	class:bustub::TransactionManager
Remove	container/hash/extendible_hash_table.cpp	/^bool HASH_TABLE_TYPE::Remove(Transaction *transaction, const KeyType &key, const ValueType &value) {$/;"	f	class:bustub::HASH_TABLE_TYPE
Remove	storage/index/b_plus_tree.cpp	/^void BPLUSTREE_TYPE::Remove(const KeyType &key, Transaction *transaction) {}$/;"	f	class:bustub::BPLUSTREE_TYPE
Remove	storage/page/b_plus_tree_internal_page.cpp	/^void B_PLUS_TREE_INTERNAL_PAGE_TYPE::Remove(int index) {}$/;"	f	class:bustub::B_PLUS_TREE_INTERNAL_PAGE_TYPE
Remove	storage/page/hash_table_block_page.cpp	/^void HASH_TABLE_BLOCK_TYPE::Remove(slot_offset_t bucket_ind) {}$/;"	f	class:bustub::HASH_TABLE_BLOCK_TYPE
Remove	storage/page/hash_table_bucket_page.cpp	/^bool HASH_TABLE_BUCKET_TYPE::Remove(KeyType key, ValueType value, KeyComparator cmp) {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
RemoveAt	storage/page/hash_table_bucket_page.cpp	/^void HASH_TABLE_BUCKET_TYPE::RemoveAt(uint32_t bucket_idx) {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
RemoveFromFile	storage/index/b_plus_tree.cpp	/^void BPLUSTREE_TYPE::RemoveFromFile(const std::string &file_name, Transaction *transaction) {$/;"	f	class:bustub::BPLUSTREE_TYPE
Replacer	include/buffer/replacer.h	/^class Replacer {$/;"	c	namespace:bustub
ResetMemory	include/storage/page/page.h	/^  inline void ResetMemory() { memset(data_, OFFSET_PAGE_START, PAGE_SIZE); }$/;"	f	class:bustub::Page
Resize	container/hash/linear_probe_hash_table.cpp	/^void HASH_TABLE_TYPE::Resize(size_t initial_size) {}$/;"	f	class:bustub::HASH_TABLE_TYPE
ResumeTransactions	concurrency/transaction_manager.cpp	/^void TransactionManager::ResumeTransactions() { global_txn_latch_.WUnlock(); }$/;"	f	class:bustub::TransactionManager
RollbackDelete	storage/page/table_page.cpp	/^void TablePage::RollbackDelete(const RID &rid, Transaction *txn, LogManager *log_manager) {$/;"	f	class:bustub::TablePage
RollbackDelete	storage/table/table_heap.cpp	/^void TableHeap::RollbackDelete(const RID &rid, Transaction *txn) {$/;"	f	class:bustub::TableHeap
RowMatrix	include/primer/p0_starter.h	/^  RowMatrix(int rows, int cols) : Matrix<T>(rows, cols) {$/;"	f	class:bustub::RowMatrix
RowMatrix	include/primer/p0_starter.h	/^class RowMatrix : public Matrix<T> {$/;"	c	namespace:bustub
RowMatrixOperations	include/primer/p0_starter.h	/^class RowMatrixOperations {$/;"	c	namespace:bustub
RunFlushThread	recovery/log_manager.cpp	/^void LogManager::RunFlushThread() {}$/;"	f	class:bustub::LogManager
SHARED	include/concurrency/lock_manager.h	/^  enum class LockMode { SHARED, EXCLUSIVE };$/;"	m	class:bustub::LockManager::LockMode
SHRINKING	include/concurrency/transaction.h	/^enum class TransactionState { GROWING, SHRINKING, COMMITTED, ABORTED };$/;"	m	class:bustub::TransactionState
SIZE_PAGE_HEADER	include/storage/page/page.h	/^  static constexpr size_t SIZE_PAGE_HEADER = 8;$/;"	m	class:bustub::Page
SIZE_TABLE_PAGE_HEADER	include/storage/page/table_page.h	/^  static constexpr size_t SIZE_TABLE_PAGE_HEADER = 24;$/;"	m	class:bustub::TablePage
SIZE_TUPLE	include/storage/page/table_page.h	/^  static constexpr size_t SIZE_TUPLE = 8;$/;"	m	class:bustub::TablePage
SMALLINT	include/type/type_id.h	/^enum TypeId { INVALID = 0, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, VARCHAR, TIMESTAMP };$/;"	e	enum:bustub::TypeId
SMALLINT_COMPARE_FUNC	type/smallint_type.cpp	21;"	d	file:
SMALLINT_MODIFY_FUNC	type/smallint_type.cpp	41;"	d	file:
ScanKey	storage/index/b_plus_tree_index.cpp	/^void BPLUSTREE_INDEX_TYPE::ScanKey(const Tuple &key, std::vector<RID> *result, Transaction *transaction) {$/;"	f	class:bustub::BPLUSTREE_INDEX_TYPE
ScanKey	storage/index/extendible_hash_table_index.cpp	/^void HASH_TABLE_INDEX_TYPE::ScanKey(const Tuple &key, std::vector<RID> *result, Transaction *transaction) {$/;"	f	class:bustub::HASH_TABLE_INDEX_TYPE
ScanKey	storage/index/linear_probe_hash_table_index.cpp	/^void HASH_TABLE_INDEX_TYPE::ScanKey(const Tuple &key, std::vector<RID> *result, Transaction *transaction) {$/;"	f	class:bustub::HASH_TABLE_INDEX_TYPE
Schema	catalog/schema.cpp	/^Schema::Schema(const std::vector<Column> &columns) : tuple_is_inlined_(true) {$/;"	f	class:bustub::Schema
Schema	include/catalog/schema.h	/^class Schema {$/;"	c	namespace:bustub
Schema	include/execution/executors/abstract_executor.h	/^  virtual auto GetOutputSchema() -> const Schema * = 0;$/;"	m	class:bustub::AbstractExecutor
SeqScan	include/execution/plans/abstract_plan.h	/^  SeqScan,$/;"	m	class:bustub::PlanType
SeqScanExecutor	execution/seq_scan_executor.cpp	/^SeqScanExecutor::SeqScanExecutor(ExecutorContext *exec_ctx, const SeqScanPlanNode *plan)$/;"	f	class:bustub::SeqScanExecutor
SeqScanExecutor	include/execution/executors/seq_scan_executor.h	/^class SeqScanExecutor : public AbstractExecutor {$/;"	c	namespace:bustub
SeqScanPlanNode	include/execution/plans/seq_scan_plan.h	/^  SeqScanPlanNode(const Schema *output, const AbstractExpression *predicate, table_oid_t table_oid)$/;"	f	class:bustub::SeqScanPlanNode
SeqScanPlanNode	include/execution/plans/seq_scan_plan.h	/^class SeqScanPlanNode : public AbstractPlanNode {$/;"	c	namespace:bustub
Serial	include/catalog/table_generator.h	/^  enum class Dist : uint8_t { Uniform, Zipf_50, Zipf_75, Zipf_95, Zipf_99, Serial, Cyclic };$/;"	m	class:bustub::TableGenerator::Dist
SerializeTo	include/type/value.h	/^  inline void SerializeTo(char *storage) const { Type::GetInstance(type_id_)->SerializeTo(*this, storage); }$/;"	f	class:bustub::Value
SerializeTo	storage/table/tuple.cpp	/^void Tuple::SerializeTo(char *storage) const {$/;"	f	class:bustub::Tuple
SerializeTo	type/bigint_type.cpp	/^void BigintType::SerializeTo(const Value &val, char *storage) const {$/;"	f	class:bustub::BigintType
SerializeTo	type/boolean_type.cpp	/^void BooleanType::SerializeTo(const Value &val, char *storage) const {$/;"	f	class:bustub::BooleanType
SerializeTo	type/decimal_type.cpp	/^void DecimalType::SerializeTo(const Value &val, char *storage) const {$/;"	f	class:bustub::DecimalType
SerializeTo	type/integer_type.cpp	/^void IntegerType::SerializeTo(const Value &val, char *storage) const {$/;"	f	class:bustub::IntegerType
SerializeTo	type/smallint_type.cpp	/^void SmallintType::SerializeTo(const Value &val, char *storage) const {$/;"	f	class:bustub::SmallintType
SerializeTo	type/timestamp_type.cpp	/^void TimestampType::SerializeTo(const Value &val, char *storage) const {$/;"	f	class:bustub::TimestampType
SerializeTo	type/tinyint_type.cpp	/^void TinyintType::SerializeTo(const Value &val, char *storage) const {$/;"	f	class:bustub::TinyintType
SerializeTo	type/type.cpp	/^void Type::SerializeTo(const Value &val __attribute__((unused)), char *storage __attribute__((unused))) const {$/;"	f	class:bustub::Type
SerializeTo	type/varlen_type.cpp	/^void VarlenType::SerializeTo(const Value &val, char *storage) const {$/;"	f	class:bustub::VarlenType
Set	include/common/rid.h	/^  inline void Set(page_id_t page_id, uint32_t slot_num) {$/;"	f	class:bustub::RID
SetBucketPageId	storage/page/hash_table_directory_page.cpp	/^void HashTableDirectoryPage::SetBucketPageId(uint32_t bucket_idx, page_id_t bucket_page_id) {$/;"	f	class:bustub::HashTableDirectoryPage
SetFlushLogFuture	include/storage/disk/disk_manager.h	/^  inline void SetFlushLogFuture(std::future<void> *f) { flush_log_f_ = f; }$/;"	f	class:bustub::DiskManager
SetFreeSpacePointer	include/storage/page/table_page.h	/^  void SetFreeSpacePointer(uint32_t free_space_pointer) {$/;"	f	class:bustub::TablePage
SetFromInteger	include/storage/index/generic_key.h	/^  inline void SetFromInteger(int64_t key) {$/;"	f	class:bustub::GenericKey
SetFromKey	include/storage/index/generic_key.h	/^  inline void SetFromKey(const Tuple &tuple) {$/;"	f	class:bustub::GenericKey
SetKeyAt	storage/page/b_plus_tree_internal_page.cpp	/^void B_PLUS_TREE_INTERNAL_PAGE_TYPE::SetKeyAt(int index, const KeyType &key) {}$/;"	f	class:bustub::B_PLUS_TREE_INTERNAL_PAGE_TYPE
SetLSN	include/storage/page/page.h	/^  inline void SetLSN(lsn_t lsn) { memcpy(GetData() + OFFSET_LSN, &lsn, sizeof(lsn_t)); }$/;"	f	class:bustub::Page
SetLSN	storage/page/b_plus_tree_page.cpp	/^void BPlusTreePage::SetLSN(lsn_t lsn) { lsn_ = lsn; }$/;"	f	class:bustub::BPlusTreePage
SetLSN	storage/page/hash_table_directory_page.cpp	/^void HashTableDirectoryPage::SetLSN(lsn_t lsn) { lsn_ = lsn; }$/;"	f	class:bustub::HashTableDirectoryPage
SetLSN	storage/page/hash_table_header_page.cpp	/^void HashTableHeaderPage::SetLSN(lsn_t lsn) {}$/;"	f	class:bustub::HashTableHeaderPage
SetLocalDepth	storage/page/hash_table_directory_page.cpp	/^void HashTableDirectoryPage::SetLocalDepth(uint32_t bucket_idx, uint8_t local_depth) {$/;"	f	class:bustub::HashTableDirectoryPage
SetMaxSize	storage/page/b_plus_tree_page.cpp	/^void BPlusTreePage::SetMaxSize(int size) {}$/;"	f	class:bustub::BPlusTreePage
SetNextPageId	include/storage/page/table_page.h	/^  void SetNextPageId(page_id_t next_page_id) {$/;"	f	class:bustub::TablePage
SetNextPageId	storage/page/b_plus_tree_leaf_page.cpp	/^void B_PLUS_TREE_LEAF_PAGE_TYPE::SetNextPageId(page_id_t next_page_id) {}$/;"	f	class:bustub::B_PLUS_TREE_LEAF_PAGE_TYPE
SetOccupied	storage/page/hash_table_bucket_page.cpp	/^void HASH_TABLE_BUCKET_TYPE::SetOccupied(uint32_t bucket_idx) {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
SetPageId	storage/page/b_plus_tree_page.cpp	/^void BPlusTreePage::SetPageId(page_id_t page_id) {}$/;"	f	class:bustub::BPlusTreePage
SetPageId	storage/page/hash_table_directory_page.cpp	/^void HashTableDirectoryPage::SetPageId(bustub::page_id_t page_id) { page_id_ = page_id; }$/;"	f	class:bustub::HashTableDirectoryPage
SetPageId	storage/page/hash_table_header_page.cpp	/^void HashTableHeaderPage::SetPageId(bustub::page_id_t page_id) {}$/;"	f	class:bustub::HashTableHeaderPage
SetPageType	storage/page/b_plus_tree_page.cpp	/^void BPlusTreePage::SetPageType(IndexPageType page_type) {}$/;"	f	class:bustub::BPlusTreePage
SetParentPageId	storage/page/b_plus_tree_page.cpp	/^void BPlusTreePage::SetParentPageId(page_id_t parent_page_id) {}$/;"	f	class:bustub::BPlusTreePage
SetPersistentLSN	include/recovery/log_manager.h	/^  inline void SetPersistentLSN(lsn_t lsn) { persistent_lsn_ = lsn; }$/;"	f	class:bustub::LogManager
SetPrevLSN	include/concurrency/transaction.h	/^  inline void SetPrevLSN(lsn_t prev_lsn) { prev_lsn_ = prev_lsn; }$/;"	f	class:bustub::Transaction
SetPrevPageId	include/storage/page/table_page.h	/^  void SetPrevPageId(page_id_t prev_page_id) {$/;"	f	class:bustub::TablePage
SetReadable	storage/page/hash_table_bucket_page.cpp	/^void HASH_TABLE_BUCKET_TYPE::SetReadable(uint32_t bucket_idx) {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
SetRecordCount	storage/page/header_page.cpp	/^void HeaderPage::SetRecordCount(int record_count) { memcpy(GetData(), &record_count, 4); }$/;"	f	class:bustub::HeaderPage
SetSize	storage/page/b_plus_tree_page.cpp	/^void BPlusTreePage::SetSize(int size) {}$/;"	f	class:bustub::BPlusTreePage
SetSize	storage/page/hash_table_header_page.cpp	/^void HashTableHeaderPage::SetSize(size_t size) {}$/;"	f	class:bustub::HashTableHeaderPage
SetState	include/concurrency/transaction.h	/^  inline void SetState(TransactionState state) { state_ = state; }$/;"	f	class:bustub::Transaction
SetTupleCount	include/storage/page/table_page.h	/^  void SetTupleCount(uint32_t tuple_count) { memcpy(GetData() + OFFSET_TUPLE_COUNT, &tuple_count, sizeof(uint32_t)); }$/;"	f	class:bustub::TablePage
SetTupleOffsetAtSlot	include/storage/page/table_page.h	/^  void SetTupleOffsetAtSlot(uint32_t slot_num, uint32_t offset) {$/;"	f	class:bustub::TablePage
SetTupleSize	include/storage/page/table_page.h	/^  void SetTupleSize(uint32_t slot_num, uint32_t size) {$/;"	f	class:bustub::TablePage
ShutDown	storage/disk/disk_manager.cpp	/^void DiskManager::ShutDown() {$/;"	f	class:bustub::DiskManager
SimpleAggregationHashTable	include/execution/executors/aggregation_executor.h	/^  SimpleAggregationHashTable(const std::vector<const AbstractExpression *> &agg_exprs,$/;"	f	class:bustub::SimpleAggregationHashTable
SimpleAggregationHashTable	include/execution/executors/aggregation_executor.h	/^class SimpleAggregationHashTable {$/;"	c	namespace:bustub
Size	buffer/lru_replacer.cpp	/^size_t LRUReplacer::Size() {$/;"	f	class:bustub::LRUReplacer
Size	storage/page/hash_table_directory_page.cpp	/^uint32_t HashTableDirectoryPage::Size() { return 0; }$/;"	f	class:bustub::HashTableDirectoryPage
SmallintType	include/type/smallint_type.h	/^class SmallintType : public IntegerParentType {$/;"	c	namespace:bustub
SmallintType	type/smallint_type.cpp	/^SmallintType::SmallintType() : IntegerParentType(TypeId::SMALLINT) {}$/;"	f	class:bustub::SmallintType
SplitInsert	container/hash/extendible_hash_table.cpp	/^bool HASH_TABLE_TYPE::SplitInsert(Transaction *transaction, const KeyType &key, const ValueType &value) {$/;"	f	class:bustub::HASH_TABLE_TYPE
StartNewTree	storage/index/b_plus_tree.cpp	/^void BPLUSTREE_TYPE::StartNewTree(const KeyType &key, const ValueType &value) {}$/;"	f	class:bustub::BPLUSTREE_TYPE
StopFlushThread	recovery/log_manager.cpp	/^void LogManager::StopFlushThread() {}$/;"	f	class:bustub::LogManager
StringUtil	include/common/util/string_util.h	/^class StringUtil {$/;"	c	namespace:bustub
SumAggregate	include/execution/plans/aggregation_plan.h	/^enum class AggregationType { CountAggregate, SumAggregate, MinAggregate, MaxAggregate };$/;"	m	class:bustub::AggregationType
Swap	include/type/value.h	/^  friend void Swap(Value &first, Value &second) {$/;"	f	class:bustub::Value
TEST1_SIZE	include/catalog/table_generator.h	/^static constexpr uint32_t TEST1_SIZE = 1000;$/;"	m	namespace:bustub
TEST2_SIZE	include/catalog/table_generator.h	/^static constexpr uint32_t TEST2_SIZE = 100;$/;"	m	namespace:bustub
TEST3_SIZE	include/catalog/table_generator.h	/^static constexpr uint32_t TEST3_SIZE = 100;$/;"	m	namespace:bustub
TEST4_SIZE	include/catalog/table_generator.h	/^static constexpr uint32_t TEST4_SIZE = 100;$/;"	m	namespace:bustub
TEST6_SIZE	include/catalog/table_generator.h	/^static constexpr uint32_t TEST6_SIZE = 100;$/;"	m	namespace:bustub
TEST7_SIZE	include/catalog/table_generator.h	/^static constexpr uint32_t TEST7_SIZE = 100;$/;"	m	namespace:bustub
TEST8_SIZE	include/catalog/table_generator.h	/^static constexpr uint32_t TEST8_SIZE = 10;$/;"	m	namespace:bustub
TEST9_SIZE	include/catalog/table_generator.h	/^static constexpr uint32_t TEST9_SIZE = 10;$/;"	m	namespace:bustub
TEST_VARLEN_SIZE	include/catalog/table_generator.h	/^static constexpr uint32_t TEST_VARLEN_SIZE = 10;$/;"	m	namespace:bustub
TIMESTAMP	include/type/type_id.h	/^enum TypeId { INVALID = 0, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, VARCHAR, TIMESTAMP };$/;"	e	enum:bustub::TypeId
TINYINT	include/type/type_id.h	/^enum TypeId { INVALID = 0, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, VARCHAR, TIMESTAMP };$/;"	e	enum:bustub::TypeId
TINYINT_COMPARE_FUNC	type/tinyint_type.cpp	22;"	d	file:
TINYINT_MODIFY_FUNC	type/tinyint_type.cpp	42;"	d	file:
TableGenerator	include/catalog/table_generator.h	/^  explicit TableGenerator(ExecutorContext *exec_ctx) : exec_ctx_{exec_ctx} {}$/;"	f	class:bustub::TableGenerator
TableGenerator	include/catalog/table_generator.h	/^class TableGenerator {$/;"	c	namespace:bustub
TableHeap	include/storage/table/table_heap.h	/^class TableHeap {$/;"	c	namespace:bustub
TableHeap	storage/table/table_heap.cpp	/^TableHeap::TableHeap(BufferPoolManager *buffer_pool_manager, LockManager *lock_manager, LogManager *log_manager,$/;"	f	class:bustub::TableHeap
TableInfo	include/catalog/catalog.h	/^  TableInfo(Schema schema, std::string name, std::unique_ptr<TableHeap> &&table, table_oid_t oid)$/;"	f	struct:bustub::TableInfo
TableInfo	include/catalog/catalog.h	/^struct TableInfo {$/;"	s	namespace:bustub
TableInsertMeta	include/catalog/table_generator.h	/^    TableInsertMeta(const char *name, uint32_t num_rows, std::vector<ColumnInsertMeta> col_meta)$/;"	f	struct:bustub::TableGenerator::TableInsertMeta
TableInsertMeta	include/catalog/table_generator.h	/^  struct TableInsertMeta {$/;"	s	class:bustub::TableGenerator
TableIterator	include/storage/table/table_heap.h	/^  auto Begin(Transaction *txn) -> TableIterator;$/;"	m	class:bustub::TableHeap
TableIterator	include/storage/table/table_heap.h	/^  auto End() -> TableIterator;$/;"	m	class:bustub::TableHeap
TableIterator	include/storage/table/table_iterator.h	/^  TableIterator(const TableIterator &other)$/;"	f	class:bustub::TableIterator
TableIterator	include/storage/table/table_iterator.h	/^  auto operator++() -> TableIterator &;$/;"	m	class:bustub::TableIterator
TableIterator	include/storage/table/table_iterator.h	/^  auto operator++(int) -> TableIterator;$/;"	m	class:bustub::TableIterator
TableIterator	include/storage/table/table_iterator.h	/^class TableIterator {$/;"	c	namespace:bustub
TableIterator	storage/table/table_iterator.cpp	/^TableIterator::TableIterator(TableHeap *table_heap, RID rid, Transaction *txn)$/;"	f	class:bustub::TableIterator
TablePage	include/storage/page/table_page.h	/^class TablePage : public Page {$/;"	c	namespace:bustub
TableWriteRecord	include/concurrency/transaction.h	/^  TableWriteRecord(RID rid, WType wtype, const Tuple &tuple, TableHeap *table)$/;"	f	class:bustub::TableWriteRecord
TableWriteRecord	include/concurrency/transaction.h	/^class TableWriteRecord {$/;"	c	namespace:bustub
TimestampType	include/type/timestamp_type.h	/^class TimestampType : public Type {$/;"	c	namespace:bustub
TimestampType	type/timestamp_type.cpp	/^TimestampType::TimestampType() : Type(TypeId::TIMESTAMP) {}$/;"	f	class:bustub::TimestampType
TinyintType	include/type/tinyint_type.h	/^class TinyintType : public IntegerParentType {$/;"	c	namespace:bustub
TinyintType	type/tinyint_type.cpp	/^TinyintType::TinyintType() : IntegerParentType(TINYINT) {}$/;"	f	class:bustub::TinyintType
TmpTuple	include/storage/table/tmp_tuple.h	/^  TmpTuple(page_id_t page_id, size_t offset) : page_id_(page_id), offset_(offset) {}$/;"	f	class:bustub::TmpTuple
TmpTuple	include/storage/table/tmp_tuple.h	/^class TmpTuple {$/;"	c	namespace:bustub
TmpTuplePage	include/storage/page/tmp_tuple_page.h	/^class TmpTuplePage : public Page {$/;"	c	namespace:bustub
ToGraph	storage/index/b_plus_tree.cpp	/^void BPLUSTREE_TYPE::ToGraph(BPlusTreePage *page, BufferPoolManager *bpm, std::ofstream &out) const {$/;"	f	class:bustub::BPLUSTREE_TYPE
ToString	storage/index/b_plus_tree.cpp	/^void BPLUSTREE_TYPE::ToString(BPlusTreePage *page, BufferPoolManager *bpm) const {$/;"	f	class:bustub::BPLUSTREE_TYPE
Transaction	include/concurrency/transaction.h	/^  explicit Transaction(txn_id_t txn_id, IsolationLevel isolation_level = IsolationLevel::REPEATABLE_READ)$/;"	f	class:bustub::Transaction
Transaction	include/concurrency/transaction.h	/^class Transaction {$/;"	c	namespace:bustub
Transaction	include/concurrency/transaction_manager.h	/^      -> Transaction *;$/;"	m	class:bustub::TransactionManager
TransactionAbortException	include/concurrency/transaction.h	/^  explicit TransactionAbortException(txn_id_t txn_id, AbortReason abort_reason)$/;"	f	class:bustub::TransactionAbortException
TransactionAbortException	include/concurrency/transaction.h	/^class TransactionAbortException : public std::exception {$/;"	c	namespace:bustub
TransactionManager	include/concurrency/transaction_manager.h	/^  explicit TransactionManager(LockManager *lock_manager, LogManager *log_manager = nullptr)$/;"	f	class:bustub::TransactionManager
TransactionManager	include/concurrency/transaction_manager.h	/^class TransactionManager {$/;"	c	namespace:bustub
TransactionState	include/concurrency/transaction.h	/^enum class TransactionState { GROWING, SHRINKING, COMMITTED, ABORTED };$/;"	c	namespace:bustub
Tuple	include/storage/table/table_iterator.h	/^  auto operator*() -> const Tuple &;$/;"	m	class:bustub::TableIterator
Tuple	include/storage/table/table_iterator.h	/^  auto operator->() -> Tuple *;$/;"	m	class:bustub::TableIterator
Tuple	include/storage/table/tuple.h	/^  auto KeyFromTuple(const Schema &schema, const Schema &key_schema, const std::vector<uint32_t> &key_attrs) -> Tuple;$/;"	m	class:bustub::Tuple
Tuple	include/storage/table/tuple.h	/^  auto operator=(const Tuple &other) -> Tuple &;$/;"	m	class:bustub::Tuple
Tuple	include/storage/table/tuple.h	/^  explicit Tuple(RID rid) : rid_(rid) {}$/;"	f	class:bustub::Tuple
Tuple	include/storage/table/tuple.h	/^class Tuple {$/;"	c	namespace:bustub
Tuple	storage/table/tuple.cpp	/^Tuple::Tuple(const Tuple &other) : allocated_(other.allocated_), rid_(other.rid_), size_(other.size_) {$/;"	f	class:bustub::Tuple
Tuple	storage/table/tuple.cpp	/^Tuple::Tuple(std::vector<Value> values, const Schema *schema) : allocated_(true) {$/;"	f	class:bustub::Tuple
Type	include/type/type.h	/^  explicit Type(TypeId type_id) : type_id_(type_id) {}$/;"	f	class:bustub::CmpBool::Type
Type	include/type/type.h	/^class Type {$/;"	c	class:bustub::CmpBool
TypeId	include/type/type_id.h	/^enum TypeId { INVALID = 0, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, VARCHAR, TIMESTAMP };$/;"	g	namespace:bustub
TypeUtil	include/type/type_util.h	/^class TypeUtil {$/;"	c	namespace:bustub
UNKNOWN_TYPE	include/common/exception.h	/^  UNKNOWN_TYPE = 3,$/;"	m	class:bustub::ExceptionType
UNLOCK_ON_SHRINKING	include/concurrency/transaction.h	/^  UNLOCK_ON_SHRINKING,$/;"	m	class:bustub::AbortReason
UNREACHABLE	include/common/macros.h	22;"	d
UPDATE	include/recovery/log_record.h	/^  UPDATE,$/;"	m	class:bustub::LogRecordType
UPGRADE_CONFLICT	include/concurrency/transaction.h	/^  UPGRADE_CONFLICT,$/;"	m	class:bustub::AbortReason
Undo	recovery/log_recovery.cpp	/^void LogRecovery::Undo() {}$/;"	f	class:bustub::LogRecovery
Uniform	include/catalog/table_generator.h	/^  enum class Dist : uint8_t { Uniform, Zipf_50, Zipf_75, Zipf_95, Zipf_99, Serial, Cyclic };$/;"	m	class:bustub::TableGenerator::Dist
Unpin	buffer/clock_replacer.cpp	/^void ClockReplacer::Unpin(frame_id_t frame_id) {}$/;"	f	class:bustub::ClockReplacer
Unpin	buffer/lru_replacer.cpp	/^void LRUReplacer::Unpin(frame_id_t frame_id) {$/;"	f	class:bustub::LRUReplacer
UnpinPgImp	buffer/buffer_pool_manager_instance.cpp	/^bool BufferPoolManagerInstance::UnpinPgImp(page_id_t page_id, bool is_dirty) {$/;"	f	class:bustub::BufferPoolManagerInstance
Update	include/execution/plans/abstract_plan.h	/^  Update,$/;"	m	class:bustub::PlanType
UpdateExecutor	execution/update_executor.cpp	/^UpdateExecutor::UpdateExecutor(ExecutorContext *exec_ctx, const UpdatePlanNode *plan,$/;"	f	class:bustub::UpdateExecutor
UpdateExecutor	include/execution/executors/update_executor.h	/^class UpdateExecutor : public AbstractExecutor {$/;"	c	namespace:bustub
UpdateInfo	include/execution/plans/update_plan.h	/^  UpdateInfo(UpdateType type, int update_val) : type_{type}, update_val_{update_val} {}$/;"	f	struct:bustub::UpdateInfo
UpdateInfo	include/execution/plans/update_plan.h	/^struct UpdateInfo {$/;"	s	namespace:bustub
UpdatePlanNode	include/execution/plans/update_plan.h	/^  UpdatePlanNode(const AbstractPlanNode *child, table_oid_t table_oid,$/;"	f	class:bustub::UpdatePlanNode
UpdatePlanNode	include/execution/plans/update_plan.h	/^class UpdatePlanNode : public AbstractPlanNode {$/;"	c	namespace:bustub
UpdateRootPageId	storage/index/b_plus_tree.cpp	/^void BPLUSTREE_TYPE::UpdateRootPageId(int insert_record) {$/;"	f	class:bustub::BPLUSTREE_TYPE
UpdateType	include/execution/plans/update_plan.h	/^enum class UpdateType { Add, Set };$/;"	c	namespace:bustub
VARCHAR	include/type/type_id.h	/^enum TypeId { INVALID = 0, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, VARCHAR, TIMESTAMP };$/;"	e	enum:bustub::TypeId
VARLEN_COMPARE_FUNC	type/varlen_type.cpp	21;"	d	file:
Val	include/execution/executors/aggregation_executor.h	/^    const AggregateValue &Val() { return iter_->second; }$/;"	f	class:bustub::SimpleAggregationHashTable::Iterator
Val	include/type/value.h	/^  union Val {$/;"	u	class:bustub::Value
ValidatePageId	buffer/buffer_pool_manager_instance.cpp	/^void BufferPoolManagerInstance::ValidatePageId(const page_id_t page_id) const {$/;"	f	class:bustub::BufferPoolManagerInstance
Value	include/execution/expressions/abstract_expression.h	/^                            const Schema *right_schema) const -> Value = 0;$/;"	m	class:bustub::AbstractExpression
Value	include/execution/expressions/abstract_expression.h	/^      -> Value = 0;$/;"	m	class:bustub::AbstractExpression
Value	include/execution/expressions/abstract_expression.h	/^  virtual auto Evaluate(const Tuple *tuple, const Schema *schema) const -> Value = 0;$/;"	m	class:bustub::AbstractExpression
Value	include/storage/table/tuple.h	/^  auto GetValue(const Schema *schema, uint32_t column_idx) const -> Value;$/;"	m	class:bustub::Tuple
Value	include/type/integer_parent_type.h	/^  auto AddValue(const Value &left, const Value &right) const -> Value;$/;"	m	class:bustub::IntegerParentType
Value	include/type/integer_parent_type.h	/^  auto DivideValue(const Value &left, const Value &right) const -> Value;$/;"	m	class:bustub::IntegerParentType
Value	include/type/integer_parent_type.h	/^  auto ModuloValue(const Value &left, const Value &right) const -> Value;$/;"	m	class:bustub::IntegerParentType
Value	include/type/integer_parent_type.h	/^  auto MultiplyValue(const Value &left, const Value &right) const -> Value;$/;"	m	class:bustub::IntegerParentType
Value	include/type/integer_parent_type.h	/^  auto SubtractValue(const Value &left, const Value &right) const -> Value;$/;"	m	class:bustub::IntegerParentType
Value	include/type/type.h	/^  static auto GetMaxValue(TypeId type_id) -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/type.h	/^  static auto GetMinValue(TypeId type_id) -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/type.h	/^  virtual auto Add(const Value &left, const Value &right) const -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/type.h	/^  virtual auto CastAs(const Value &val, TypeId type_id) const -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/type.h	/^  virtual auto Copy(const Value &val) const -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/type.h	/^  virtual auto DeserializeFrom(const char *storage) const -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/type.h	/^  virtual auto Divide(const Value &left, const Value &right) const -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/type.h	/^  virtual auto Max(const Value &left, const Value &right) const -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/type.h	/^  virtual auto Min(const Value &left, const Value &right) const -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/type.h	/^  virtual auto Modulo(const Value &left, const Value &right) const -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/type.h	/^  virtual auto Multiply(const Value &left, const Value &right) const -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/type.h	/^  virtual auto OperateNull(const Value &val, const Value &right) const -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/type.h	/^  virtual auto Sqrt(const Value &val) const -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/type.h	/^  virtual auto Subtract(const Value &left, const Value &right) const -> Value;$/;"	m	class:bustub::CmpBool::Type
Value	include/type/value.h	/^  Value() : Value(TypeId::INVALID) {}$/;"	f	class:bustub::Value
Value	include/type/value.h	/^  auto operator=(Value other) -> Value &;$/;"	m	class:bustub::Value
Value	include/type/value.h	/^  explicit Value(const TypeId type) : manage_data_(false), type_id_(type) { size_.len_ = BUSTUB_VALUE_NULL; }$/;"	f	class:bustub::Value
Value	include/type/value.h	/^class Value {$/;"	c	namespace:bustub
Value	type/value.cpp	/^Value::Value(TypeId type, const char *data, uint32_t len, bool manage_data) : Value(type) {$/;"	f	class:bustub::Value
Value	type/value.cpp	/^Value::Value(TypeId type, const std::string &data) : Value(type) {$/;"	f	class:bustub::Value
Value	type/value.cpp	/^Value::Value(TypeId type, double d) : Value(type) {$/;"	f	class:bustub::Value
Value	type/value.cpp	/^Value::Value(TypeId type, float f) : Value(type) {$/;"	f	class:bustub::Value
Value	type/value.cpp	/^Value::Value(TypeId type, int16_t i) : Value(type) {$/;"	f	class:bustub::Value
Value	type/value.cpp	/^Value::Value(TypeId type, int32_t i) : Value(type) {$/;"	f	class:bustub::Value
Value	type/value.cpp	/^Value::Value(TypeId type, int64_t i) : Value(type) {$/;"	f	class:bustub::Value
Value	type/value.cpp	/^Value::Value(TypeId type, int8_t i) : Value(type) {$/;"	f	class:bustub::Value
Value	type/value.cpp	/^Value::Value(TypeId type, uint64_t i) : Value(type) {$/;"	f	class:bustub::Value
Value	type/value.cpp	/^Value::Value(const Value &other) {$/;"	f	class:bustub::Value
ValueAt	storage/page/hash_table_bucket_page.cpp	/^ValueType HASH_TABLE_BUCKET_TYPE::ValueAt(uint32_t bucket_idx) const {$/;"	f	class:bustub::HASH_TABLE_BUCKET_TYPE
ValueFactory	include/type/value_factory.h	/^class ValueFactory {$/;"	c	namespace:bustub
ValueType	include/storage/page/b_plus_tree_internal_page.h	/^  auto Lookup(const KeyType &key, const KeyComparator &comparator) const -> ValueType;$/;"	m	class:bustub::BPlusTreeInternalPage
ValueType	include/storage/page/b_plus_tree_internal_page.h	/^  auto RemoveAndReturnOnlyChild() -> ValueType;$/;"	m	class:bustub::BPlusTreeInternalPage
ValueType	include/storage/page/b_plus_tree_internal_page.h	/^  auto ValueAt(int index) const -> ValueType;$/;"	m	class:bustub::BPlusTreeInternalPage
ValueType	include/storage/page/hash_table_block_page.h	/^  auto ValueAt(slot_offset_t bucket_ind) const -> ValueType;$/;"	m	class:bustub::HashTableBlockPage
VarlenType	include/type/varlen_type.h	/^class VarlenType : public Type {$/;"	c	namespace:bustub
VarlenType	type/varlen_type.cpp	/^VarlenType::VarlenType(TypeId type) : Type(type) {}$/;"	f	class:bustub::VarlenType
VerifyIntegrity	container/hash/extendible_hash_table.cpp	/^void HASH_TABLE_TYPE::VerifyIntegrity() {$/;"	f	class:bustub::HASH_TABLE_TYPE
VerifyIntegrity	storage/page/hash_table_directory_page.cpp	/^void HashTableDirectoryPage::VerifyIntegrity() {$/;"	f	class:bustub::HashTableDirectoryPage
Victim	buffer/lru_replacer.cpp	/^bool LRUReplacer::Victim(frame_id_t *frame_id) {$/;"	f	class:bustub::LRUReplacer
WLatch	include/storage/page/page.h	/^  inline void WLatch() { rwlatch_.WLock(); }$/;"	f	class:bustub::Page
WLock	include/common/rwlatch.h	/^  void WLock() {$/;"	f	class:bustub::ReaderWriterLatch
WType	include/concurrency/transaction.h	/^enum class WType { INSERT = 0, DELETE, UPDATE };$/;"	c	namespace:bustub
WUnlatch	include/storage/page/page.h	/^  inline void WUnlatch() { rwlatch_.WUnlock(); }$/;"	f	class:bustub::Page
WUnlock	include/common/rwlatch.h	/^  void WUnlock() {$/;"	f	class:bustub::ReaderWriterLatch
WriteLog	storage/disk/disk_manager.cpp	/^void DiskManager::WriteLog(char *log_data, int size) {$/;"	f	class:bustub::DiskManager
WritePage	storage/disk/disk_manager.cpp	/^void DiskManager::WritePage(page_id_t page_id, const char *page_data) {$/;"	f	class:bustub::DiskManager
Zipf_50	include/catalog/table_generator.h	/^  enum class Dist : uint8_t { Uniform, Zipf_50, Zipf_75, Zipf_95, Zipf_99, Serial, Cyclic };$/;"	m	class:bustub::TableGenerator::Dist
Zipf_75	include/catalog/table_generator.h	/^  enum class Dist : uint8_t { Uniform, Zipf_50, Zipf_75, Zipf_95, Zipf_99, Serial, Cyclic };$/;"	m	class:bustub::TableGenerator::Dist
Zipf_95	include/catalog/table_generator.h	/^  enum class Dist : uint8_t { Uniform, Zipf_50, Zipf_75, Zipf_95, Zipf_99, Serial, Cyclic };$/;"	m	class:bustub::TableGenerator::Dist
Zipf_99	include/catalog/table_generator.h	/^  enum class Dist : uint8_t { Uniform, Zipf_50, Zipf_75, Zipf_95, Zipf_99, Serial, Cyclic };$/;"	m	class:bustub::TableGenerator::Dist
__FUNCTION__	include/common/logger.h	86;"	d
__SHORT_FILE__	include/common/logger.h	50;"	d
abort_reason_	include/concurrency/transaction.h	/^  AbortReason abort_reason_;$/;"	m	class:bustub::TransactionAbortException
active_txn_	include/recovery/log_recovery.h	/^  std::unordered_map<txn_id_t, lsn_t> active_txn_;$/;"	m	class:bustub::LogRecovery
agg_exprs_	include/execution/executors/aggregation_executor.h	/^  const std::vector<const AbstractExpression *> &agg_exprs_;$/;"	m	class:bustub::SimpleAggregationHashTable
agg_types_	include/execution/executors/aggregation_executor.h	/^  const std::vector<AggregationType> &agg_types_;$/;"	m	class:bustub::SimpleAggregationHashTable
agg_types_	include/execution/plans/aggregation_plan.h	/^  std::vector<AggregationType> agg_types_;$/;"	m	class:bustub::AggregationPlanNode
aggregates_	include/execution/plans/aggregation_plan.h	/^  std::vector<Value> aggregates_;$/;"	m	struct:bustub::AggregateValue
aggregates_	include/execution/plans/aggregation_plan.h	/^  std::vector<const AbstractExpression *> aggregates_;$/;"	m	class:bustub::AggregationPlanNode
array_	include/storage/page/b_plus_tree_internal_page.h	/^  MappingType array_[1];$/;"	m	class:bustub::BPlusTreeInternalPage
array_	include/storage/page/b_plus_tree_leaf_page.h	/^  MappingType array_[1];$/;"	m	class:bustub::BPlusTreeLeafPage
array_	include/storage/page/hash_table_block_page.h	/^  MappingType array_[1];$/;"	m	class:bustub::HashTableBlockPage
array_	include/storage/page/hash_table_bucket_page.h	/^  MappingType array_[0];$/;"	m	class:bustub::HashTableBucketPage
bigint_	include/type/value.h	/^    int64_t bigint_;$/;"	m	union:bustub::Value::Val
block_page_ids_	include/storage/page/hash_table_header_page.h	/^  __attribute__((unused)) page_id_t block_page_ids_[1];$/;"	m	class:bustub::HashTableHeaderPage
bool	include/buffer/buffer_pool_manager.h	/^  virtual auto DeletePgImp(page_id_t page_id) -> bool = 0;$/;"	m	class:bustub::BufferPoolManager
bool	include/buffer/buffer_pool_manager.h	/^  virtual auto FlushPgImp(page_id_t page_id) -> bool = 0;$/;"	m	class:bustub::BufferPoolManager
bool	include/buffer/buffer_pool_manager.h	/^  virtual auto UnpinPgImp(page_id_t page_id, bool is_dirty) -> bool = 0;$/;"	m	class:bustub::BufferPoolManager
bool	include/buffer/replacer.h	/^  virtual auto Victim(frame_id_t *frame_id) -> bool = 0;$/;"	m	class:bustub::Replacer
bool	include/common/util/string_util.h	/^  static auto Contains(const std::string &haystack, const std::string &needle) -> bool;$/;"	m	class:bustub::StringUtil
bool	include/common/util/string_util.h	/^  static auto EndsWith(const std::string &str, const std::string &suffix) -> bool;$/;"	m	class:bustub::StringUtil
bool	include/common/util/string_util.h	/^  static auto StartsWith(const std::string &str, const std::string &prefix) -> bool;$/;"	m	class:bustub::StringUtil
bool	include/concurrency/lock_manager.h	/^  auto LockExclusive(Transaction *txn, const RID &rid) -> bool;$/;"	m	class:bustub::LockManager
bool	include/concurrency/lock_manager.h	/^  auto LockShared(Transaction *txn, const RID &rid) -> bool;$/;"	m	class:bustub::LockManager
bool	include/concurrency/lock_manager.h	/^  auto LockUpgrade(Transaction *txn, const RID &rid) -> bool;$/;"	m	class:bustub::LockManager
bool	include/concurrency/lock_manager.h	/^  auto Unlock(Transaction *txn, const RID &rid) -> bool;$/;"	m	class:bustub::LockManager
bool	include/container/hash/hash_table.h	/^  virtual auto GetValue(Transaction *transaction, const KeyType &key, std::vector<ValueType> *result) -> bool = 0;$/;"	m	class:bustub::HashTable
bool	include/container/hash/hash_table.h	/^  virtual auto Insert(Transaction *transaction, const KeyType &key, const ValueType &value) -> bool = 0;$/;"	m	class:bustub::HashTable
bool	include/container/hash/hash_table.h	/^  virtual auto Remove(Transaction *transaction, const KeyType &key, const ValueType &value) -> bool = 0;$/;"	m	class:bustub::HashTable
bool	include/execution/executors/abstract_executor.h	/^  virtual auto Next(Tuple *tuple, RID *rid) -> bool = 0;$/;"	m	class:bustub::AbstractExecutor
bool	include/recovery/log_recovery.h	/^  auto DeserializeLogRecord(const char *data, LogRecord *log_record) -> bool;$/;"	m	class:bustub::LogRecovery
bool	include/storage/disk/disk_manager.h	/^  auto GetFlushState() const -> bool;$/;"	m	class:bustub::DiskManager
bool	include/storage/disk/disk_manager.h	/^  auto ReadLog(char *log_data, int size, int offset) -> bool;$/;"	m	class:bustub::DiskManager
bool	include/storage/index/b_plus_tree.h	/^                int index, Transaction *transaction = nullptr) -> bool;$/;"	m	class:bustub::BPlusTree
bool	include/storage/index/b_plus_tree.h	/^  auto AdjustRoot(BPlusTreePage *node) -> bool;$/;"	m	class:bustub::BPlusTree
bool	include/storage/index/b_plus_tree.h	/^  auto CoalesceOrRedistribute(N *node, Transaction *transaction = nullptr) -> bool;$/;"	m	class:bustub::BPlusTree
bool	include/storage/index/b_plus_tree.h	/^  auto GetValue(const KeyType &key, std::vector<ValueType> *result, Transaction *transaction = nullptr) -> bool;$/;"	m	class:bustub::BPlusTree
bool	include/storage/index/b_plus_tree.h	/^  auto Insert(const KeyType &key, const ValueType &value, Transaction *transaction = nullptr) -> bool;$/;"	m	class:bustub::BPlusTree
bool	include/storage/index/b_plus_tree.h	/^  auto InsertIntoLeaf(const KeyType &key, const ValueType &value, Transaction *transaction = nullptr) -> bool;$/;"	m	class:bustub::BPlusTree
bool	include/storage/index/b_plus_tree.h	/^  auto IsEmpty() const -> bool;$/;"	m	class:bustub::BPlusTree
bool	include/storage/index/index_iterator.h	/^  auto IsEnd() -> bool;$/;"	m	class:bustub::IndexIterator
bool	include/storage/page/b_plus_tree_leaf_page.h	/^  auto Lookup(const KeyType &key, ValueType *value, const KeyComparator &comparator) const -> bool;$/;"	m	class:bustub::BPlusTreeLeafPage
bool	include/storage/page/b_plus_tree_page.h	/^  auto IsLeafPage() const -> bool;$/;"	m	class:bustub::BPlusTreePage
bool	include/storage/page/b_plus_tree_page.h	/^  auto IsRootPage() const -> bool;$/;"	m	class:bustub::BPlusTreePage
bool	include/storage/page/hash_table_block_page.h	/^  auto GetValue(KeyType key, KeyComparator cmp, std::vector<ValueType> *result) -> bool;$/;"	m	class:bustub::HashTableBlockPage
bool	include/storage/page/hash_table_block_page.h	/^  auto Insert(KeyType key, ValueType value, KeyComparator cmp) -> bool;$/;"	m	class:bustub::HashTableBlockPage
bool	include/storage/page/hash_table_block_page.h	/^  auto Insert(slot_offset_t bucket_ind, const KeyType &key, const ValueType &value) -> bool;$/;"	m	class:bustub::HashTableBlockPage
bool	include/storage/page/hash_table_block_page.h	/^  auto IsEmpty() -> bool;$/;"	m	class:bustub::HashTableBlockPage
bool	include/storage/page/hash_table_block_page.h	/^  auto IsFull() -> bool;$/;"	m	class:bustub::HashTableBlockPage
bool	include/storage/page/hash_table_block_page.h	/^  auto IsOccupied(slot_offset_t bucket_ind) const -> bool;$/;"	m	class:bustub::HashTableBlockPage
bool	include/storage/page/hash_table_block_page.h	/^  auto IsReadable(slot_offset_t bucket_ind) const -> bool;$/;"	m	class:bustub::HashTableBlockPage
bool	include/storage/page/hash_table_block_page.h	/^  auto Remove(KeyType key, ValueType value, KeyComparator cmp) -> bool;$/;"	m	class:bustub::HashTableBlockPage
bool	include/storage/page/header_page.h	/^  auto DeleteRecord(const std::string &name) -> bool;$/;"	m	class:bustub::HeaderPage
bool	include/storage/page/header_page.h	/^  auto GetRootId(const std::string &name, page_id_t *root_id) -> bool;$/;"	m	class:bustub::HeaderPage
bool	include/storage/page/header_page.h	/^  auto InsertRecord(const std::string &name, page_id_t root_id) -> bool;$/;"	m	class:bustub::HeaderPage
bool	include/storage/page/header_page.h	/^  auto UpdateRecord(const std::string &name, page_id_t root_id) -> bool;$/;"	m	class:bustub::HeaderPage
bool	include/storage/page/table_page.h	/^                   LockManager *lock_manager, LogManager *log_manager) -> bool;$/;"	m	class:bustub::TablePage
bool	include/storage/page/table_page.h	/^      -> bool;$/;"	m	class:bustub::TablePage
bool	include/storage/page/table_page.h	/^  auto GetFirstTupleRid(RID *first_rid) -> bool;$/;"	m	class:bustub::TablePage
bool	include/storage/page/table_page.h	/^  auto GetNextTupleRid(const RID &cur_rid, RID *next_rid) -> bool;$/;"	m	class:bustub::TablePage
bool	include/storage/page/table_page.h	/^  auto GetTuple(const RID &rid, Tuple *tuple, Transaction *txn, LockManager *lock_manager) -> bool;$/;"	m	class:bustub::TablePage
bool	include/storage/page/table_page.h	/^  auto MarkDelete(const RID &rid, Transaction *txn, LockManager *lock_manager, LogManager *log_manager) -> bool;$/;"	m	class:bustub::TablePage
bool	include/storage/table/table_heap.h	/^  auto GetTuple(const RID &rid, Tuple *tuple, Transaction *txn) -> bool;$/;"	m	class:bustub::TableHeap
bool	include/storage/table/table_heap.h	/^  auto InsertTuple(const Tuple &tuple, RID *rid, Transaction *txn) -> bool;$/;"	m	class:bustub::TableHeap
bool	include/storage/table/table_heap.h	/^  auto MarkDelete(const RID &rid, Transaction *txn) -> bool;  \/\/ for delete$/;"	m	class:bustub::TableHeap
bool	include/storage/table/table_heap.h	/^  auto UpdateTuple(const Tuple &tuple, const RID &rid, Transaction *txn) -> bool;$/;"	m	class:bustub::TableHeap
bool	include/type/type.h	/^  auto IsCoercableFrom(TypeId type_id) const -> bool;$/;"	m	class:bustub::CmpBool::Type
bool	include/type/type.h	/^  virtual auto IsInlined(const Value &val) const -> bool;$/;"	m	class:bustub::CmpBool::Type
bool	include/type/type.h	/^  virtual auto IsZero(const Value &val) const -> bool;$/;"	m	class:bustub::CmpBool::Type
bool	include/type/value.h	/^  auto CheckComparable(const Value &o) const -> bool;$/;"	m	class:bustub::Value
bool	include/type/value.h	/^  auto CheckInteger() const -> bool;$/;"	m	class:bustub::Value
boolean_	include/type/value.h	/^    int8_t boolean_;$/;"	m	union:bustub::Value::Val
bpm_	include/catalog/catalog.h	/^  [[maybe_unused]] BufferPoolManager *bpm_;$/;"	m	class:bustub::Catalog
bpm_	include/execution/execution_engine.h	/^  [[maybe_unused]] BufferPoolManager *bpm_;$/;"	m	class:bustub::ExecutionEngine
bpm_	include/execution/executor_context.h	/^  BufferPoolManager *bpm_;$/;"	m	class:bustub::ExecutorContext
bucket_page_ids_	include/storage/page/hash_table_directory_page.h	/^  page_id_t bucket_page_ids_[DIRECTORY_ARRAY_SIZE];$/;"	m	class:bustub::HashTableDirectoryPage
buffer_	include/execution/executors/nested_loop_join_executor.h	/^  std::vector<Tuple> buffer_;$/;"	m	class:bustub::NestedLoopJoinExecutor
buffer_pool_manager_	include/common/bustub_instance.h	/^  BufferPoolManager *buffer_pool_manager_;$/;"	m	class:bustub::BustubInstance
buffer_pool_manager_	include/container/hash/extendible_hash_table.h	/^  BufferPoolManager *buffer_pool_manager_;$/;"	m	class:bustub::ExtendibleHashTable
buffer_pool_manager_	include/container/hash/linear_probe_hash_table.h	/^  BufferPoolManager *buffer_pool_manager_;$/;"	m	class:bustub::LinearProbeHashTable
buffer_pool_manager_	include/recovery/checkpoint_manager.h	/^  BufferPoolManager *buffer_pool_manager_ __attribute__((__unused__));$/;"	m	class:bustub::CheckpointManager
buffer_pool_manager_	include/recovery/log_recovery.h	/^  BufferPoolManager *buffer_pool_manager_ __attribute__((__unused__));$/;"	m	class:bustub::LogRecovery
buffer_pool_manager_	include/storage/index/b_plus_tree.h	/^  BufferPoolManager *buffer_pool_manager_;$/;"	m	class:bustub::BPlusTree
buffer_pool_manager_	include/storage/table/table_heap.h	/^  BufferPoolManager *buffer_pool_manager_;$/;"	m	class:bustub::TableHeap
buffer_used	storage/disk/disk_manager.cpp	/^static char *buffer_used;$/;"	m	namespace:bustub	file:
bustub	buffer/buffer_pool_manager_instance.cpp	/^namespace bustub {$/;"	n	file:
bustub	buffer/clock_replacer.cpp	/^namespace bustub {$/;"	n	file:
bustub	buffer/lru_replacer.cpp	/^namespace bustub {$/;"	n	file:
bustub	buffer/parallel_buffer_pool_manager.cpp	/^namespace bustub {$/;"	n	file:
bustub	catalog/column.cpp	/^namespace bustub {$/;"	n	file:
bustub	catalog/schema.cpp	/^namespace bustub {$/;"	n	file:
bustub	catalog/table_generator.cpp	/^namespace bustub {$/;"	n	file:
bustub	common/config.cpp	/^namespace bustub {$/;"	n	file:
bustub	common/util/string_util.cpp	/^namespace bustub {$/;"	n	file:
bustub	concurrency/lock_manager.cpp	/^namespace bustub {$/;"	n	file:
bustub	concurrency/transaction_manager.cpp	/^namespace bustub {$/;"	n	file:
bustub	container/hash/extendible_hash_table.cpp	/^namespace bustub {$/;"	n	file:
bustub	container/hash/linear_probe_hash_table.cpp	/^namespace bustub {$/;"	n	file:
bustub	execution/aggregation_executor.cpp	/^namespace bustub {$/;"	n	file:
bustub	execution/delete_executor.cpp	/^namespace bustub {$/;"	n	file:
bustub	execution/distinct_executor.cpp	/^namespace bustub {$/;"	n	file:
bustub	execution/executor_factory.cpp	/^namespace bustub {$/;"	n	file:
bustub	execution/hash_join_executor.cpp	/^namespace bustub {$/;"	n	file:
bustub	execution/index_scan_executor.cpp	/^namespace bustub {$/;"	n	file:
bustub	execution/insert_executor.cpp	/^namespace bustub {$/;"	n	file:
bustub	execution/limit_executor.cpp	/^namespace bustub {$/;"	n	file:
bustub	execution/mock_scan_executor.cpp	/^namespace bustub {$/;"	n	file:
bustub	execution/nested_index_join_executor.cpp	/^namespace bustub {$/;"	n	file:
bustub	execution/nested_loop_join_executor.cpp	/^namespace bustub {$/;"	n	file:
bustub	execution/seq_scan_executor.cpp	/^namespace bustub {$/;"	n	file:
bustub	execution/update_executor.cpp	/^namespace bustub {$/;"	n	file:
bustub	include/buffer/buffer_pool_manager.h	/^namespace bustub {$/;"	n
bustub	include/buffer/buffer_pool_manager_instance.h	/^namespace bustub {$/;"	n
bustub	include/buffer/clock_replacer.h	/^namespace bustub {$/;"	n
bustub	include/buffer/lru_replacer.h	/^namespace bustub {$/;"	n
bustub	include/buffer/parallel_buffer_pool_manager.h	/^namespace bustub {$/;"	n
bustub	include/buffer/replacer.h	/^namespace bustub {$/;"	n
bustub	include/catalog/catalog.h	/^namespace bustub {$/;"	n
bustub	include/catalog/column.h	/^namespace bustub {$/;"	n
bustub	include/catalog/schema.h	/^namespace bustub {$/;"	n
bustub	include/catalog/table_generator.h	/^namespace bustub {$/;"	n
bustub	include/common/bustub_instance.h	/^namespace bustub {$/;"	n
bustub	include/common/config.h	/^namespace bustub {$/;"	n
bustub	include/common/exception.h	/^namespace bustub {$/;"	n
bustub	include/common/logger.h	/^namespace bustub {$/;"	n
bustub	include/common/macros.h	/^namespace bustub {$/;"	n
bustub	include/common/rid.h	/^namespace bustub {$/;"	n
bustub	include/common/rwlatch.h	/^namespace bustub {$/;"	n
bustub	include/common/util/hash_util.h	/^namespace bustub {$/;"	n
bustub	include/common/util/string_util.h	/^namespace bustub {$/;"	n
bustub	include/concurrency/lock_manager.h	/^namespace bustub {$/;"	n
bustub	include/concurrency/transaction.h	/^namespace bustub {$/;"	n
bustub	include/concurrency/transaction_manager.h	/^namespace bustub {$/;"	n
bustub	include/container/hash/extendible_hash_table.h	/^namespace bustub {$/;"	n
bustub	include/container/hash/hash_function.h	/^namespace bustub {$/;"	n
bustub	include/container/hash/hash_table.h	/^namespace bustub {$/;"	n
bustub	include/container/hash/linear_probe_hash_table.h	/^namespace bustub {$/;"	n
bustub	include/execution/execution_engine.h	/^namespace bustub {$/;"	n
bustub	include/execution/executor_context.h	/^namespace bustub {$/;"	n
bustub	include/execution/executor_factory.h	/^namespace bustub {$/;"	n
bustub	include/execution/executors/abstract_executor.h	/^namespace bustub {$/;"	n
bustub	include/execution/executors/aggregation_executor.h	/^namespace bustub {$/;"	n
bustub	include/execution/executors/delete_executor.h	/^namespace bustub {$/;"	n
bustub	include/execution/executors/distinct_executor.h	/^namespace bustub {$/;"	n
bustub	include/execution/executors/hash_join_executor.h	/^namespace bustub {$/;"	n
bustub	include/execution/executors/index_scan_executor.h	/^namespace bustub {$/;"	n
bustub	include/execution/executors/insert_executor.h	/^namespace bustub {$/;"	n
bustub	include/execution/executors/limit_executor.h	/^namespace bustub {$/;"	n
bustub	include/execution/executors/mock_scan_executor.h	/^namespace bustub {$/;"	n
bustub	include/execution/executors/nested_index_join_executor.h	/^namespace bustub {$/;"	n
bustub	include/execution/executors/nested_loop_join_executor.h	/^namespace bustub {$/;"	n
bustub	include/execution/executors/seq_scan_executor.h	/^namespace bustub {$/;"	n
bustub	include/execution/executors/update_executor.h	/^namespace bustub {$/;"	n
bustub	include/execution/expressions/abstract_expression.h	/^namespace bustub {$/;"	n
bustub	include/execution/expressions/aggregate_value_expression.h	/^namespace bustub {$/;"	n
bustub	include/execution/expressions/column_value_expression.h	/^namespace bustub {$/;"	n
bustub	include/execution/expressions/comparison_expression.h	/^namespace bustub {$/;"	n
bustub	include/execution/expressions/constant_value_expression.h	/^namespace bustub {$/;"	n
bustub	include/execution/plans/abstract_plan.h	/^namespace bustub {$/;"	n
bustub	include/execution/plans/aggregation_plan.h	/^namespace bustub {$/;"	n
bustub	include/execution/plans/delete_plan.h	/^namespace bustub {$/;"	n
bustub	include/execution/plans/distinct_plan.h	/^namespace bustub {$/;"	n
bustub	include/execution/plans/hash_join_plan.h	/^namespace bustub {$/;"	n
bustub	include/execution/plans/index_scan_plan.h	/^namespace bustub {$/;"	n
bustub	include/execution/plans/insert_plan.h	/^namespace bustub {$/;"	n
bustub	include/execution/plans/limit_plan.h	/^namespace bustub {$/;"	n
bustub	include/execution/plans/mock_scan_plan.h	/^namespace bustub {$/;"	n
bustub	include/execution/plans/nested_index_join_plan.h	/^namespace bustub {$/;"	n
bustub	include/execution/plans/nested_loop_join_plan.h	/^namespace bustub {$/;"	n
bustub	include/execution/plans/seq_scan_plan.h	/^namespace bustub {$/;"	n
bustub	include/execution/plans/update_plan.h	/^namespace bustub {$/;"	n
bustub	include/primer/p0_starter.h	/^namespace bustub {$/;"	n
bustub	include/recovery/checkpoint_manager.h	/^namespace bustub {$/;"	n
bustub	include/recovery/log_manager.h	/^namespace bustub {$/;"	n
bustub	include/recovery/log_record.h	/^namespace bustub {$/;"	n
bustub	include/recovery/log_recovery.h	/^namespace bustub {$/;"	n
bustub	include/storage/disk/disk_manager.h	/^namespace bustub {$/;"	n
bustub	include/storage/index/b_plus_tree.h	/^namespace bustub {$/;"	n
bustub	include/storage/index/b_plus_tree_index.h	/^namespace bustub {$/;"	n
bustub	include/storage/index/extendible_hash_table_index.h	/^namespace bustub {$/;"	n
bustub	include/storage/index/generic_key.h	/^namespace bustub {$/;"	n
bustub	include/storage/index/hash_comparator.h	/^namespace bustub {$/;"	n
bustub	include/storage/index/index.h	/^namespace bustub {$/;"	n
bustub	include/storage/index/index_iterator.h	/^namespace bustub {$/;"	n
bustub	include/storage/index/int_comparator.h	/^namespace bustub {$/;"	n
bustub	include/storage/index/linear_probe_hash_table_index.h	/^namespace bustub {$/;"	n
bustub	include/storage/page/b_plus_tree_internal_page.h	/^namespace bustub {$/;"	n
bustub	include/storage/page/b_plus_tree_leaf_page.h	/^namespace bustub {$/;"	n
bustub	include/storage/page/b_plus_tree_page.h	/^namespace bustub {$/;"	n
bustub	include/storage/page/hash_table_block_page.h	/^namespace bustub {$/;"	n
bustub	include/storage/page/hash_table_bucket_page.h	/^namespace bustub {$/;"	n
bustub	include/storage/page/hash_table_directory_page.h	/^namespace bustub {$/;"	n
bustub	include/storage/page/hash_table_header_page.h	/^namespace bustub {$/;"	n
bustub	include/storage/page/header_page.h	/^namespace bustub {$/;"	n
bustub	include/storage/page/page.h	/^namespace bustub {$/;"	n
bustub	include/storage/page/table_page.h	/^namespace bustub {$/;"	n
bustub	include/storage/page/tmp_tuple_page.h	/^namespace bustub {$/;"	n
bustub	include/storage/table/table_heap.h	/^namespace bustub {$/;"	n
bustub	include/storage/table/table_iterator.h	/^namespace bustub {$/;"	n
bustub	include/storage/table/tmp_tuple.h	/^namespace bustub {$/;"	n
bustub	include/storage/table/tuple.h	/^namespace bustub {$/;"	n
bustub	include/type/abstract_pool.h	/^namespace bustub {$/;"	n
bustub	include/type/bigint_type.h	/^namespace bustub {$/;"	n
bustub	include/type/boolean_type.h	/^namespace bustub {$/;"	n
bustub	include/type/decimal_type.h	/^namespace bustub {$/;"	n
bustub	include/type/integer_parent_type.h	/^namespace bustub {$/;"	n
bustub	include/type/integer_type.h	/^namespace bustub {$/;"	n
bustub	include/type/limits.h	/^namespace bustub {$/;"	n
bustub	include/type/numeric_type.h	/^namespace bustub {$/;"	n
bustub	include/type/smallint_type.h	/^namespace bustub {$/;"	n
bustub	include/type/timestamp_type.h	/^namespace bustub {$/;"	n
bustub	include/type/tinyint_type.h	/^namespace bustub {$/;"	n
bustub	include/type/type.h	/^namespace bustub {$/;"	n
bustub	include/type/type_id.h	/^namespace bustub {$/;"	n
bustub	include/type/type_util.h	/^namespace bustub {$/;"	n
bustub	include/type/value.h	/^namespace bustub {$/;"	n
bustub	include/type/value_factory.h	/^namespace bustub {$/;"	n
bustub	include/type/varlen_type.h	/^namespace bustub {$/;"	n
bustub	recovery/checkpoint_manager.cpp	/^namespace bustub {$/;"	n	file:
bustub	recovery/log_manager.cpp	/^namespace bustub {$/;"	n	file:
bustub	recovery/log_recovery.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/disk/disk_manager.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/index/b_plus_tree.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/index/b_plus_tree_index.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/index/extendible_hash_table_index.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/index/index_iterator.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/index/linear_probe_hash_table_index.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/page/b_plus_tree_internal_page.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/page/b_plus_tree_leaf_page.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/page/b_plus_tree_page.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/page/hash_table_block_page.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/page/hash_table_bucket_page.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/page/hash_table_directory_page.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/page/hash_table_header_page.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/page/header_page.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/page/table_page.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/table/table_heap.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/table/table_iterator.cpp	/^namespace bustub {$/;"	n	file:
bustub	storage/table/tuple.cpp	/^namespace bustub {$/;"	n	file:
bustub	type/bigint_type.cpp	/^namespace bustub {$/;"	n	file:
bustub	type/boolean_type.cpp	/^namespace bustub {$/;"	n	file:
bustub	type/decimal_type.cpp	/^namespace bustub {$/;"	n	file:
bustub	type/integer_parent_type.cpp	/^namespace bustub {$/;"	n	file:
bustub	type/integer_type.cpp	/^namespace bustub {$/;"	n	file:
bustub	type/smallint_type.cpp	/^namespace bustub {$/;"	n	file:
bustub	type/timestamp_type.cpp	/^namespace bustub {$/;"	n	file:
bustub	type/tinyint_type.cpp	/^namespace bustub {$/;"	n	file:
bustub	type/type.cpp	/^namespace bustub {$/;"	n	file:
bustub	type/value.cpp	/^namespace bustub {$/;"	n	file:
bustub	type/varlen_type.cpp	/^namespace bustub {$/;"	n	file:
catalog_	include/concurrency/transaction.h	/^  Catalog *catalog_;$/;"	m	class:bustub::IndexWriteRecord
catalog_	include/execution/execution_engine.h	/^  [[maybe_unused]] Catalog *catalog_;$/;"	m	class:bustub::ExecutionEngine
catalog_	include/execution/executor_context.h	/^  Catalog *catalog_;$/;"	m	class:bustub::ExecutorContext
checkpoint_manager_	include/common/bustub_instance.h	/^  CheckpointManager *checkpoint_manager_;$/;"	m	class:bustub::BustubInstance
child_	include/execution/executors/aggregation_executor.h	/^  std::unique_ptr<AbstractExecutor> child_;$/;"	m	class:bustub::AggregationExecutor
child_executor_	include/execution/executors/delete_executor.h	/^  std::unique_ptr<AbstractExecutor> child_executor_;$/;"	m	class:bustub::DeleteExecutor
child_executor_	include/execution/executors/distinct_executor.h	/^  std::unique_ptr<AbstractExecutor> child_executor_;$/;"	m	class:bustub::DistinctExecutor
child_executor_	include/execution/executors/insert_executor.h	/^  std::unique_ptr<AbstractExecutor> child_executor_;$/;"	m	class:bustub::InsertExecutor
child_executor_	include/execution/executors/limit_executor.h	/^  std::unique_ptr<AbstractExecutor> child_executor_;$/;"	m	class:bustub::LimitExecutor
child_executor_	include/execution/executors/update_executor.h	/^  std::unique_ptr<AbstractExecutor> child_executor_;$/;"	m	class:bustub::UpdateExecutor
children_	include/execution/expressions/abstract_expression.h	/^  std::vector<const AbstractExpression *> children_;$/;"	m	class:bustub::AbstractExpression
children_	include/execution/expressions/comparison_expression.h	/^  std::vector<const AbstractExpression *> children_;$/;"	m	class:bustub::ComparisonExpression
children_	include/execution/plans/abstract_plan.h	/^  std::vector<const AbstractPlanNode *> children_;$/;"	m	class:bustub::AbstractPlanNode
col_idx_	include/execution/expressions/column_value_expression.h	/^  uint32_t col_idx_;$/;"	m	class:bustub::ColumnValueExpression
col_meta_	include/catalog/table_generator.h	/^    std::vector<ColumnInsertMeta> col_meta_;$/;"	m	struct:bustub::TableGenerator::TableInsertMeta
cols_	include/primer/p0_starter.h	/^  int cols_;$/;"	m	class:bustub::Matrix
column_name_	include/catalog/column.h	/^  std::string column_name_;$/;"	m	class:bustub::Column
column_type_	include/catalog/column.h	/^  TypeId column_type_;$/;"	m	class:bustub::Column
columns_	include/catalog/schema.h	/^  std::vector<Column> columns_;$/;"	m	class:bustub::Schema
comp_type_	include/execution/expressions/comparison_expression.h	/^  ComparisonType comp_type_;$/;"	m	class:bustub::ComparisonExpression
comparator_	include/container/hash/extendible_hash_table.h	/^  KeyComparator comparator_;$/;"	m	class:bustub::ExtendibleHashTable
comparator_	include/container/hash/linear_probe_hash_table.h	/^  KeyComparator comparator_;$/;"	m	class:bustub::LinearProbeHashTable
comparator_	include/storage/index/b_plus_tree.h	/^  KeyComparator comparator_;$/;"	m	class:bustub::BPlusTree
comparator_	include/storage/index/b_plus_tree_index.h	/^  KeyComparator comparator_;$/;"	m	class:bustub::BPlusTreeIndex
comparator_	include/storage/index/extendible_hash_table_index.h	/^  KeyComparator comparator_;$/;"	m	class:bustub::ExtendibleHashTableIndex
comparator_	include/storage/index/linear_probe_hash_table_index.h	/^  KeyComparator comparator_;$/;"	m	class:bustub::LinearProbeHashTableIndex
const_varlen_	include/type/value.h	/^    const char *const_varlen_;$/;"	m	union:bustub::Value::Val
container_	include/storage/index/b_plus_tree_index.h	/^  BPlusTree<KeyType, ValueType, KeyComparator> container_;$/;"	m	class:bustub::BPlusTreeIndex
container_	include/storage/index/extendible_hash_table_index.h	/^  ExtendibleHashTable<KeyType, ValueType, KeyComparator> container_;$/;"	m	class:bustub::ExtendibleHashTableIndex
container_	include/storage/index/linear_probe_hash_table_index.h	/^  LinearProbeHashTable<KeyType, ValueType, KeyComparator> container_;$/;"	m	class:bustub::LinearProbeHashTableIndex
cursor_	include/execution/executors/mock_scan_executor.h	/^  std::size_t cursor_;$/;"	m	class:bustub::MockScanExecutor
cv_	include/concurrency/lock_manager.h	/^    std::condition_variable cv_;$/;"	m	class:bustub::LockManager::LockRequestQueue
cv_	include/recovery/log_manager.h	/^  std::condition_variable cv_;$/;"	m	class:bustub::LogManager
cycle_detection_interval	common/config.cpp	/^std::chrono::milliseconds cycle_detection_interval = std::chrono::milliseconds(50);$/;"	m	namespace:bustub	file:
data_	include/primer/p0_starter.h	/^  T **data_;$/;"	m	class:bustub::RowMatrix
data_	include/storage/index/generic_key.h	/^  char data_[KeySize];$/;"	m	class:bustub::GenericKey
data_idx_	include/buffer/lru_replacer.h	/^  std::unordered_map<frame_id_t, LinkListNode *> data_idx_;$/;"	m	class:bustub::LRUReplacer
data_latch_	include/buffer/lru_replacer.h	/^  std::mutex data_latch_;$/;"	m	class:bustub::LRUReplacer
db_io_	include/storage/disk/disk_manager.h	/^  std::fstream db_io_;$/;"	m	class:bustub::DiskManager
db_io_latch_	include/storage/disk/disk_manager.h	/^  std::mutex db_io_latch_;$/;"	m	class:bustub::DiskManager
decimal_	include/type/value.h	/^    double decimal_;$/;"	m	union:bustub::Value::Val
delete_rid_	include/recovery/log_record.h	/^  RID delete_rid_;$/;"	m	class:bustub::LogRecord
delete_tuple_	include/recovery/log_record.h	/^  Tuple delete_tuple_;$/;"	m	class:bustub::LogRecord
deleted_page_set_	include/concurrency/transaction.h	/^  std::shared_ptr<std::unordered_set<page_id_t>> deleted_page_set_;$/;"	m	class:bustub::Transaction
directory_page_id_	include/container/hash/extendible_hash_table.h	/^  page_id_t directory_page_id_;$/;"	m	class:bustub::ExtendibleHashTable
disk_manager_	include/buffer/buffer_pool_manager_instance.h	/^  DiskManager *disk_manager_ __attribute__((__unused__));$/;"	m	class:bustub::BufferPoolManagerInstance
disk_manager_	include/common/bustub_instance.h	/^  DiskManager *disk_manager_;$/;"	m	class:bustub::BustubInstance
disk_manager_	include/recovery/log_manager.h	/^  DiskManager *disk_manager_ __attribute__((__unused__));$/;"	m	class:bustub::LogManager
disk_manager_	include/recovery/log_recovery.h	/^  DiskManager *disk_manager_ __attribute__((__unused__));$/;"	m	class:bustub::LogRecovery
dist_	include/catalog/table_generator.h	/^    Dist dist_;$/;"	m	struct:bustub::TableGenerator::ColumnInsertMeta
elem_type_id_	include/type/value.h	/^    TypeId elem_type_id_;$/;"	m	union:bustub::Value::__anon1
end_	include/execution/executors/seq_scan_executor.h	/^  TableIterator end_;$/;"	m	class:bustub::SeqScanExecutor
exclusive_lock_set_	include/concurrency/transaction.h	/^  std::shared_ptr<std::unordered_set<RID>> exclusive_lock_set_;$/;"	m	class:bustub::Transaction
exec_ctx_	include/catalog/table_generator.h	/^  ExecutorContext *exec_ctx_;$/;"	m	class:bustub::TableGenerator
exec_ctx_	include/execution/executors/abstract_executor.h	/^  ExecutorContext *exec_ctx_;$/;"	m	class:bustub::AbstractExecutor
expr_	include/catalog/column.h	/^  const AbstractExpression *expr_;$/;"	m	class:bustub::Column
file_name_	include/storage/disk/disk_manager.h	/^  std::string file_name_;$/;"	m	class:bustub::DiskManager
fixed_length_	include/catalog/column.h	/^  uint32_t fixed_length_;$/;"	m	class:bustub::Column
flush_buffer_	include/recovery/log_manager.h	/^  char *flush_buffer_;$/;"	m	class:bustub::LogManager
flush_log_	include/storage/disk/disk_manager.h	/^  bool flush_log_;$/;"	m	class:bustub::DiskManager
flush_log_f_	include/storage/disk/disk_manager.h	/^  std::future<void> *flush_log_f_;$/;"	m	class:bustub::DiskManager
flush_thread_	include/recovery/log_manager.h	/^  std::thread *flush_thread_ __attribute__((__unused__));$/;"	m	class:bustub::LogManager
free_list_	include/buffer/buffer_pool_manager_instance.h	/^  std::list<frame_id_t> free_list_;$/;"	m	class:bustub::BufferPoolManagerInstance
global_txn_latch_	include/concurrency/transaction_manager.h	/^  ReaderWriterLatch global_txn_latch_;$/;"	m	class:bustub::TransactionManager
granted_	include/concurrency/lock_manager.h	/^    bool granted_;$/;"	m	class:bustub::LockManager::LockRequest
group_bys_	include/execution/plans/aggregation_plan.h	/^  std::vector<Value> group_bys_;$/;"	m	struct:bustub::AggregateKey
group_bys_	include/execution/plans/aggregation_plan.h	/^  std::vector<const AbstractExpression *> group_bys_;$/;"	m	class:bustub::AggregationPlanNode
hash	include/common/rid.h	/^struct hash<bustub::RID> {$/;"	s	namespace:std
hash	include/execution/executors/distinct_executor.h	/^struct hash<bustub::DistinctKey> {$/;"	s	namespace:std
hash	include/execution/executors/hash_join_executor.h	/^struct hash<bustub::HashJoinKey> {$/;"	s	namespace:std
hash	include/execution/plans/aggregation_plan.h	/^struct hash<bustub::AggregateKey> {$/;"	s	namespace:std
hash_fn_	include/container/hash/extendible_hash_table.h	/^  HashFunction<KeyType> hash_fn_;$/;"	m	class:bustub::ExtendibleHashTable
hash_fn_	include/container/hash/linear_probe_hash_table.h	/^  HashFunction<KeyType> hash_fn_;$/;"	m	class:bustub::LinearProbeHashTable
hash_table_	include/execution/executors/aggregation_executor.h	/^  SimpleAggregationHashTable hash_table_;$/;"	m	class:bustub::AggregationExecutor
having_	include/execution/plans/aggregation_plan.h	/^  const AbstractExpression *having_;$/;"	m	class:bustub::AggregationPlanNode
head_	include/buffer/lru_replacer.h	/^  LinkListNode *head_;$/;"	m	class:bustub::LRUReplacer
header_page_id_	include/container/hash/linear_probe_hash_table.h	/^  page_id_t header_page_id_;$/;"	m	class:bustub::LinearProbeHashTable
index_	include/catalog/catalog.h	/^  std::unique_ptr<Index> index_;$/;"	m	struct:bustub::IndexInfo
index_name_	include/execution/plans/nested_index_join_plan.h	/^  const std::string index_name_;$/;"	m	class:bustub::NestedIndexJoinPlanNode
index_name_	include/storage/index/b_plus_tree.h	/^  std::string index_name_;$/;"	m	class:bustub::BPlusTree
index_names_	include/catalog/catalog.h	/^  std::unordered_map<std::string, std::unordered_map<std::string, index_oid_t>> index_names_;$/;"	m	class:bustub::Catalog
index_oid_	include/catalog/catalog.h	/^  index_oid_t index_oid_;$/;"	m	struct:bustub::IndexInfo
index_oid_	include/concurrency/transaction.h	/^  index_oid_t index_oid_;$/;"	m	class:bustub::IndexWriteRecord
index_oid_	include/execution/plans/index_scan_plan.h	/^      : AbstractPlanNode(output, {}), predicate_{predicate}, index_oid_(index_oid) {}$/;"	f	class:bustub::IndexScanPlanNode
index_oid_	include/execution/plans/index_scan_plan.h	/^  index_oid_t index_oid_;$/;"	m	class:bustub::IndexScanPlanNode
index_write_set_	include/concurrency/transaction.h	/^  std::shared_ptr<std::deque<IndexWriteRecord>> index_write_set_;$/;"	m	class:bustub::Transaction
indexes_	include/catalog/catalog.h	/^  std::unordered_map<index_oid_t, std::unique_ptr<IndexInfo>> indexes_;$/;"	m	class:bustub::Catalog
indexes_	include/execution/executors/delete_executor.h	/^  std::vector<IndexInfo *> indexes_;$/;"	m	class:bustub::DeleteExecutor
indexes_	include/execution/executors/insert_executor.h	/^  std::vector<IndexInfo *> indexes_;$/;"	m	class:bustub::InsertExecutor
indexes_	include/execution/executors/update_executor.h	/^  std::vector<IndexInfo *> indexes_;$/;"	m	class:bustub::UpdateExecutor
inner_table_oid_	include/execution/plans/nested_index_join_plan.h	/^  table_oid_t inner_table_oid_;$/;"	m	class:bustub::NestedIndexJoinPlanNode
inner_table_schema_	include/execution/plans/nested_index_join_plan.h	/^  const Schema *inner_table_schema_;$/;"	m	class:bustub::NestedIndexJoinPlanNode
insert_rid_	include/recovery/log_record.h	/^  RID insert_rid_;$/;"	m	class:bustub::LogRecord
insert_tuple_	include/recovery/log_record.h	/^  Tuple insert_tuple_;$/;"	m	class:bustub::LogRecord
instance_index_	include/buffer/buffer_pool_manager_instance.h	/^  const uint32_t instance_index_ = 0;$/;"	m	class:bustub::BufferPoolManagerInstance
integer_	include/type/value.h	/^    int32_t integer_;$/;"	m	union:bustub::Value::Val
internal_max_size_	include/storage/index/b_plus_tree.h	/^  int internal_max_size_;$/;"	m	class:bustub::BPlusTree
is_dirty_	include/storage/page/page.h	/^  bool is_dirty_ = false;$/;"	m	class:bustub::Page
is_group_by_term_	include/execution/expressions/aggregate_value_expression.h	/^  bool is_group_by_term_;$/;"	m	class:bustub::AggregateValueExpression
is_raw_	include/execution/executors/insert_executor.h	/^  bool is_raw_;$/;"	m	class:bustub::InsertExecutor
isolation_level_	include/concurrency/transaction.h	/^  IsolationLevel isolation_level_;$/;"	m	class:bustub::Transaction
iter_	include/execution/executors/aggregation_executor.h	/^    std::unordered_map<AggregateKey, AggregateValue>::const_iterator iter_;$/;"	m	class:bustub::SimpleAggregationHashTable::Iterator
iter_	include/execution/executors/aggregation_executor.h	/^  SimpleAggregationHashTable::Iterator iter_;$/;"	m	class:bustub::AggregationExecutor
iter_	include/execution/executors/seq_scan_executor.h	/^  TableIterator iter_;$/;"	m	class:bustub::SeqScanExecutor
k_types	include/type/type.h	/^  static Type *k_types[14];$/;"	m	class:bustub::CmpBool::Type
k_types	type/type.cpp	/^Type *Type::k_types[] = {$/;"	m	class:bustub::Type	file:
key_attrs_	include/storage/index/index.h	/^  const std::vector<uint32_t> key_attrs_;$/;"	m	class:bustub::IndexMetadata
key_schema_	include/catalog/catalog.h	/^  Schema key_schema_;$/;"	m	struct:bustub::IndexInfo
key_schema_	include/storage/index/generic_key.h	/^  Schema *key_schema_;$/;"	m	class:bustub::GenericComparator
key_schema_	include/storage/index/index.h	/^  Schema *key_schema_;$/;"	m	class:bustub::IndexMetadata
key_size_	include/catalog/catalog.h	/^  const size_t key_size_;$/;"	m	struct:bustub::IndexInfo
latch_	include/buffer/buffer_pool_manager_instance.h	/^  std::mutex latch_;$/;"	m	class:bustub::BufferPoolManagerInstance
latch_	include/concurrency/lock_manager.h	/^  std::mutex latch_;$/;"	m	class:bustub::LockManager
latch_	include/recovery/log_manager.h	/^  std::mutex latch_;$/;"	m	class:bustub::LogManager
leaf_max_size_	include/storage/index/b_plus_tree.h	/^  int leaf_max_size_;$/;"	m	class:bustub::BPlusTree
left_child_	include/execution/executors/hash_join_executor.h	/^  std::unique_ptr<AbstractExecutor> left_child_;$/;"	m	class:bustub::HashJoinExecutor
left_executor_	include/execution/executors/nested_loop_join_executor.h	/^  std::unique_ptr<AbstractExecutor> left_executor_;$/;"	m	class:bustub::NestedLoopJoinExecutor
left_key_expression_	include/execution/plans/hash_join_plan.h	/^  const AbstractExpression *left_key_expression_;$/;"	m	class:bustub::HashJoinPlanNode
len_	include/type/value.h	/^    uint32_t len_;$/;"	m	union:bustub::Value::__anon1
length_	include/catalog/schema.h	/^  uint32_t length_;$/;"	m	class:bustub::Schema
limit_	include/execution/plans/limit_plan.h	/^  std::size_t limit_;$/;"	m	class:bustub::LimitPlanNode
linear_	include/primer/p0_starter.h	/^  T *linear_;$/;"	m	class:bustub::Matrix
local_depths_	include/storage/page/hash_table_directory_page.h	/^  uint8_t local_depths_[DIRECTORY_ARRAY_SIZE];$/;"	m	class:bustub::HashTableDirectoryPage
lock_manager_	include/catalog/catalog.h	/^  [[maybe_unused]] LockManager *lock_manager_;$/;"	m	class:bustub::Catalog
lock_manager_	include/common/bustub_instance.h	/^  LockManager *lock_manager_;$/;"	m	class:bustub::BustubInstance
lock_manager_	include/concurrency/transaction_manager.h	/^  LockManager *lock_manager_ __attribute__((__unused__));$/;"	m	class:bustub::TransactionManager
lock_manager_	include/storage/table/table_heap.h	/^  LockManager *lock_manager_;$/;"	m	class:bustub::TableHeap
lock_mgr_	include/execution/executor_context.h	/^      : transaction_(transaction), catalog_{catalog}, bpm_{bpm}, txn_mgr_(txn_mgr), lock_mgr_(lock_mgr) {}$/;"	f	class:bustub::ExecutorContext
lock_mgr_	include/execution/executor_context.h	/^  LockManager *lock_mgr_;$/;"	m	class:bustub::ExecutorContext
lock_mode_	include/concurrency/lock_manager.h	/^    LockMode lock_mode_;$/;"	m	class:bustub::LockManager::LockRequest
lock_table_	include/concurrency/lock_manager.h	/^  std::unordered_map<RID, LockRequestQueue> lock_table_;$/;"	m	class:bustub::LockManager
log_buffer_	include/recovery/log_manager.h	/^  char *log_buffer_;$/;"	m	class:bustub::LogManager
log_buffer_	include/recovery/log_recovery.h	/^  char *log_buffer_;$/;"	m	class:bustub::LogRecovery
log_io_	include/storage/disk/disk_manager.h	/^  std::fstream log_io_;$/;"	m	class:bustub::DiskManager
log_manager_	include/buffer/buffer_pool_manager_instance.h	/^  LogManager *log_manager_ __attribute__((__unused__));$/;"	m	class:bustub::BufferPoolManagerInstance
log_manager_	include/catalog/catalog.h	/^  [[maybe_unused]] LogManager *log_manager_;$/;"	m	class:bustub::Catalog
log_manager_	include/common/bustub_instance.h	/^  LogManager *log_manager_;$/;"	m	class:bustub::BustubInstance
log_manager_	include/concurrency/transaction_manager.h	/^  LogManager *log_manager_ __attribute__((__unused__));$/;"	m	class:bustub::TransactionManager
log_manager_	include/recovery/checkpoint_manager.h	/^  LogManager *log_manager_ __attribute__((__unused__));$/;"	m	class:bustub::CheckpointManager
log_manager_	include/storage/table/table_heap.h	/^  LogManager *log_manager_;$/;"	m	class:bustub::TableHeap
log_name_	include/storage/disk/disk_manager.h	/^  std::string log_name_;$/;"	m	class:bustub::DiskManager
log_timeout	common/config.cpp	/^std::chrono::duration<int64_t> log_timeout = std::chrono::seconds(1);$/;"	m	namespace:bustub	file:
lsn_	include/storage/page/b_plus_tree_page.h	/^  lsn_t lsn_ __attribute__((__unused__));$/;"	m	class:bustub::BPlusTreePage
lsn_	include/storage/page/hash_table_directory_page.h	/^  lsn_t lsn_;$/;"	m	class:bustub::HashTableDirectoryPage
lsn_	include/storage/page/hash_table_header_page.h	/^  __attribute__((unused)) lsn_t lsn_;$/;"	m	class:bustub::HashTableHeaderPage
lsn_mapping_	include/recovery/log_recovery.h	/^  std::unordered_map<lsn_t, int> lsn_mapping_;$/;"	m	class:bustub::LogRecovery
lsn_t	include/recovery/log_manager.h	/^  auto AppendLogRecord(LogRecord *log_record) -> lsn_t;$/;"	m	class:bustub::LogManager
lsn_t	include/storage/page/hash_table_header_page.h	/^  auto GetLSN() const -> lsn_t;$/;"	m	class:bustub::HashTableHeaderPage
manage_data_	include/type/value.h	/^  bool manage_data_;$/;"	m	class:bustub::Value
max_	include/catalog/table_generator.h	/^    uint64_t max_;$/;"	m	struct:bustub::TableGenerator::ColumnInsertMeta
max_size_	include/storage/page/b_plus_tree_page.h	/^  int max_size_ __attribute__((__unused__));$/;"	m	class:bustub::BPlusTreePage
metadata_	include/storage/index/index.h	/^  std::unique_ptr<IndexMetadata> metadata_;$/;"	m	class:bustub::Index
min_	include/catalog/table_generator.h	/^    uint64_t min_;$/;"	m	struct:bustub::TableGenerator::ColumnInsertMeta
mutex_	include/common/rwlatch.h	/^  mutex_t mutex_;$/;"	m	class:bustub::ReaderWriterLatch
name_	include/catalog/catalog.h	/^  const std::string name_;$/;"	m	struct:bustub::TableInfo
name_	include/catalog/catalog.h	/^  std::string name_;$/;"	m	struct:bustub::IndexInfo
name_	include/catalog/table_generator.h	/^    const char *name_;$/;"	m	struct:bustub::TableGenerator::ColumnInsertMeta
name_	include/catalog/table_generator.h	/^    const char *name_;$/;"	m	struct:bustub::TableGenerator::TableInsertMeta
name_	include/storage/index/index.h	/^  std::string name_;$/;"	m	class:bustub::IndexMetadata
new_tuple_	include/recovery/log_record.h	/^  Tuple new_tuple_;$/;"	m	class:bustub::LogRecord
next_ind_	include/storage/page/hash_table_header_page.h	/^  __attribute__((unused)) size_t next_ind_;$/;"	m	class:bustub::HashTableHeaderPage
next_lsn_	include/recovery/log_manager.h	/^  std::atomic<lsn_t> next_lsn_;$/;"	m	class:bustub::LogManager
next_page_id_	include/buffer/buffer_pool_manager_instance.h	/^  std::atomic<page_id_t> next_page_id_ = instance_index_;$/;"	m	class:bustub::BufferPoolManagerInstance
next_page_id_	include/storage/page/b_plus_tree_leaf_page.h	/^  page_id_t next_page_id_;$/;"	m	class:bustub::BPlusTreeLeafPage
nullable_	include/catalog/table_generator.h	/^    bool nullable_;$/;"	m	struct:bustub::TableGenerator::ColumnInsertMeta
num_flushes_	include/storage/disk/disk_manager.h	/^  int num_flushes_;$/;"	m	class:bustub::DiskManager
num_instances_	include/buffer/buffer_pool_manager_instance.h	/^  const uint32_t num_instances_ = 1;$/;"	m	class:bustub::BufferPoolManagerInstance
num_rows_	include/catalog/table_generator.h	/^    uint32_t num_rows_;$/;"	m	struct:bustub::TableGenerator::TableInsertMeta
num_writes_	include/storage/disk/disk_manager.h	/^  int num_writes_;$/;"	m	class:bustub::DiskManager
occupied_	include/storage/page/hash_table_block_page.h	/^  std::atomic_char occupied_[(BLOCK_ARRAY_SIZE - 1) \/ 8 + 1];$/;"	m	class:bustub::HashTableBlockPage
occupied_	include/storage/page/hash_table_bucket_page.h	/^  char occupied_[(BUCKET_ARRAY_SIZE - 1) \/ 8 + 1];$/;"	m	class:bustub::HashTableBucketPage
offset_	include/recovery/log_recovery.h	/^  int offset_ __attribute__((__unused__));$/;"	m	class:bustub::LogRecovery
offset_	include/storage/table/tmp_tuple.h	/^  size_t offset_;$/;"	m	class:bustub::TmpTuple
oid_	include/catalog/catalog.h	/^  const table_oid_t oid_;$/;"	m	struct:bustub::TableInfo
old_tuple_	include/concurrency/transaction.h	/^  Tuple old_tuple_;$/;"	m	class:bustub::IndexWriteRecord
old_tuple_	include/recovery/log_record.h	/^  Tuple old_tuple_;$/;"	m	class:bustub::LogRecord
operator !=	include/execution/executors/aggregation_executor.h	/^    bool operator!=(const Iterator &other) { return this->iter_ != other.iter_; }$/;"	f	class:bustub::SimpleAggregationHashTable::Iterator
operator ()	include/execution/executors/distinct_executor.h	/^  std::size_t operator()(const bustub::DistinctKey &key) const {$/;"	f	struct:std::hash
operator ()	include/execution/executors/hash_join_executor.h	/^  std::size_t operator()(const bustub::HashJoinKey &key) const { return bustub::HashUtil::HashValue(&key.value_); }$/;"	f	struct:std::hash
operator ++	include/execution/executors/aggregation_executor.h	/^    Iterator &operator++() {$/;"	f	class:bustub::SimpleAggregationHashTable::Iterator
operator ==	include/execution/executors/aggregation_executor.h	/^    bool operator==(const Iterator &other) { return this->iter_ == other.iter_; }$/;"	f	class:bustub::SimpleAggregationHashTable::Iterator
operator ==	include/execution/executors/distinct_executor.h	/^  bool operator==(const DistinctKey &other) const {$/;"	f	struct:bustub::DistinctKey
operator ==	include/execution/executors/hash_join_executor.h	/^  bool operator==(const HashJoinKey &other) const { return value_.CompareEquals(other.value_) == CmpBool::CmpTrue; }$/;"	f	struct:bustub::HashJoinKey
outer_table_schema_	include/execution/plans/nested_index_join_plan.h	/^  const Schema *outer_table_schema_;$/;"	m	class:bustub::NestedIndexJoinPlanNode
output_buffer_	include/execution/executors/hash_join_executor.h	/^  std::vector<Tuple> output_buffer_;$/;"	m	class:bustub::HashJoinExecutor
output_schema_	include/execution/plans/abstract_plan.h	/^  const Schema *output_schema_;$/;"	m	class:bustub::AbstractPlanNode
override	include/buffer/buffer_pool_manager_instance.h	/^  Page *FetchPgImp(page_id_t page_id) override;$/;"	m	class:bustub::BufferPoolManagerInstance
override	include/buffer/buffer_pool_manager_instance.h	/^  Page *NewPgImp(page_id_t *page_id) override;$/;"	m	class:bustub::BufferPoolManagerInstance
override	include/buffer/buffer_pool_manager_instance.h	/^  bool DeletePgImp(page_id_t page_id) override;$/;"	m	class:bustub::BufferPoolManagerInstance
override	include/buffer/buffer_pool_manager_instance.h	/^  bool FlushPgImp(page_id_t page_id) override;$/;"	m	class:bustub::BufferPoolManagerInstance
override	include/buffer/buffer_pool_manager_instance.h	/^  bool UnpinPgImp(page_id_t page_id, bool is_dirty) override;$/;"	m	class:bustub::BufferPoolManagerInstance
override	include/buffer/buffer_pool_manager_instance.h	/^  void FlushAllPgsImp() override;$/;"	m	class:bustub::BufferPoolManagerInstance
override	include/buffer/buffer_pool_manager_instance.h	/^  ~BufferPoolManagerInstance() override;$/;"	m	class:bustub::BufferPoolManagerInstance
override	include/buffer/clock_replacer.h	/^  auto Size() -> size_t override;$/;"	m	class:bustub::ClockReplacer
override	include/buffer/clock_replacer.h	/^  auto Victim(frame_id_t *frame_id) -> bool override;$/;"	m	class:bustub::ClockReplacer
override	include/buffer/clock_replacer.h	/^  void Pin(frame_id_t frame_id) override;$/;"	m	class:bustub::ClockReplacer
override	include/buffer/clock_replacer.h	/^  void Unpin(frame_id_t frame_id) override;$/;"	m	class:bustub::ClockReplacer
override	include/buffer/clock_replacer.h	/^  ~ClockReplacer() override;$/;"	m	class:bustub::ClockReplacer
override	include/buffer/lru_replacer.h	/^  bool Victim(frame_id_t *frame_id) override;$/;"	m	class:bustub::LRUReplacer
override	include/buffer/lru_replacer.h	/^  size_t Size() override;$/;"	m	class:bustub::LRUReplacer
override	include/buffer/lru_replacer.h	/^  void Pin(frame_id_t frame_id) override;$/;"	m	class:bustub::LRUReplacer
override	include/buffer/lru_replacer.h	/^  void Unpin(frame_id_t frame_id) override;$/;"	m	class:bustub::LRUReplacer
override	include/buffer/lru_replacer.h	/^  ~LRUReplacer() override;$/;"	m	class:bustub::LRUReplacer
override	include/buffer/parallel_buffer_pool_manager.h	/^  auto DeletePgImp(page_id_t page_id) -> bool override;$/;"	m	class:bustub::ParallelBufferPoolManager
override	include/buffer/parallel_buffer_pool_manager.h	/^  auto FetchPgImp(page_id_t page_id) -> Page * override;$/;"	m	class:bustub::ParallelBufferPoolManager
override	include/buffer/parallel_buffer_pool_manager.h	/^  auto FlushPgImp(page_id_t page_id) -> bool override;$/;"	m	class:bustub::ParallelBufferPoolManager
override	include/buffer/parallel_buffer_pool_manager.h	/^  auto GetPoolSize() -> size_t override;$/;"	m	class:bustub::ParallelBufferPoolManager
override	include/buffer/parallel_buffer_pool_manager.h	/^  auto NewPgImp(page_id_t *page_id) -> Page * override;$/;"	m	class:bustub::ParallelBufferPoolManager
override	include/buffer/parallel_buffer_pool_manager.h	/^  auto UnpinPgImp(page_id_t page_id, bool is_dirty) -> bool override;$/;"	m	class:bustub::ParallelBufferPoolManager
override	include/buffer/parallel_buffer_pool_manager.h	/^  void FlushAllPgsImp() override;$/;"	m	class:bustub::ParallelBufferPoolManager
override	include/buffer/parallel_buffer_pool_manager.h	/^  ~ParallelBufferPoolManager() override;$/;"	m	class:bustub::ParallelBufferPoolManager
override	include/container/hash/linear_probe_hash_table.h	/^  auto GetValue(Transaction *transaction, const KeyType &key, std::vector<ValueType> *result) -> bool override;$/;"	m	class:bustub::LinearProbeHashTable
override	include/container/hash/linear_probe_hash_table.h	/^  auto Insert(Transaction *transaction, const KeyType &key, const ValueType &value) -> bool override;$/;"	m	class:bustub::LinearProbeHashTable
override	include/container/hash/linear_probe_hash_table.h	/^  auto Remove(Transaction *transaction, const KeyType &key, const ValueType &value) -> bool override;$/;"	m	class:bustub::LinearProbeHashTable
override	include/execution/executors/aggregation_executor.h	/^  bool Next(Tuple *tuple, RID *rid) override;$/;"	m	class:bustub::AggregationExecutor
override	include/execution/executors/aggregation_executor.h	/^  void Init() override;$/;"	m	class:bustub::AggregationExecutor
override	include/execution/executors/delete_executor.h	/^  bool Next([[maybe_unused]] Tuple *tuple, RID *rid) override;$/;"	m	class:bustub::DeleteExecutor
override	include/execution/executors/delete_executor.h	/^  void Init() override;$/;"	m	class:bustub::DeleteExecutor
override	include/execution/executors/distinct_executor.h	/^  bool Next(Tuple *tuple, RID *rid) override;$/;"	m	class:bustub::DistinctExecutor
override	include/execution/executors/distinct_executor.h	/^  void Init() override;$/;"	m	class:bustub::DistinctExecutor
override	include/execution/executors/hash_join_executor.h	/^  bool Next(Tuple *tuple, RID *rid) override;$/;"	m	class:bustub::HashJoinExecutor
override	include/execution/executors/hash_join_executor.h	/^  void Init() override;$/;"	m	class:bustub::HashJoinExecutor
override	include/execution/executors/index_scan_executor.h	/^  auto Next(Tuple *tuple, RID *rid) -> bool override;$/;"	m	class:bustub::IndexScanExecutor
override	include/execution/executors/index_scan_executor.h	/^  void Init() override;$/;"	m	class:bustub::IndexScanExecutor
override	include/execution/executors/insert_executor.h	/^  bool Next([[maybe_unused]] Tuple *tuple, RID *rid) override;$/;"	m	class:bustub::InsertExecutor
override	include/execution/executors/insert_executor.h	/^  void Init() override;$/;"	m	class:bustub::InsertExecutor
override	include/execution/executors/limit_executor.h	/^  bool Next(Tuple *tuple, RID *rid) override;$/;"	m	class:bustub::LimitExecutor
override	include/execution/executors/limit_executor.h	/^  void Init() override;$/;"	m	class:bustub::LimitExecutor
override	include/execution/executors/mock_scan_executor.h	/^  bool Next(Tuple *tuple, RID *rid) override;$/;"	m	class:bustub::MockScanExecutor
override	include/execution/executors/mock_scan_executor.h	/^  void Init() override;$/;"	m	class:bustub::MockScanExecutor
override	include/execution/executors/nested_index_join_executor.h	/^  auto Next(Tuple *tuple, RID *rid) -> bool override;$/;"	m	class:bustub::NestIndexJoinExecutor
override	include/execution/executors/nested_index_join_executor.h	/^  void Init() override;$/;"	m	class:bustub::NestIndexJoinExecutor
override	include/execution/executors/nested_loop_join_executor.h	/^  bool Next(Tuple *tuple, RID *rid) override;$/;"	m	class:bustub::NestedLoopJoinExecutor
override	include/execution/executors/nested_loop_join_executor.h	/^  void Init() override;$/;"	m	class:bustub::NestedLoopJoinExecutor
override	include/execution/executors/seq_scan_executor.h	/^  bool Next(Tuple *tuple, RID *rid) override;$/;"	m	class:bustub::SeqScanExecutor
override	include/execution/executors/seq_scan_executor.h	/^  void Init() override;$/;"	m	class:bustub::SeqScanExecutor
override	include/execution/executors/update_executor.h	/^  bool Next([[maybe_unused]] Tuple *tuple, RID *rid) override;$/;"	m	class:bustub::UpdateExecutor
override	include/execution/executors/update_executor.h	/^  void Init() override;$/;"	m	class:bustub::UpdateExecutor
override	include/storage/index/b_plus_tree_index.h	/^  void DeleteEntry(const Tuple &key, RID rid, Transaction *transaction) override;$/;"	m	class:bustub::BPlusTreeIndex
override	include/storage/index/b_plus_tree_index.h	/^  void InsertEntry(const Tuple &key, RID rid, Transaction *transaction) override;$/;"	m	class:bustub::BPlusTreeIndex
override	include/storage/index/b_plus_tree_index.h	/^  void ScanKey(const Tuple &key, std::vector<RID> *result, Transaction *transaction) override;$/;"	m	class:bustub::BPlusTreeIndex
override	include/storage/index/extendible_hash_table_index.h	/^  void DeleteEntry(const Tuple &key, RID rid, Transaction *transaction) override;$/;"	m	class:bustub::ExtendibleHashTableIndex
override	include/storage/index/extendible_hash_table_index.h	/^  void InsertEntry(const Tuple &key, RID rid, Transaction *transaction) override;$/;"	m	class:bustub::ExtendibleHashTableIndex
override	include/storage/index/extendible_hash_table_index.h	/^  void ScanKey(const Tuple &key, std::vector<RID> *result, Transaction *transaction) override;$/;"	m	class:bustub::ExtendibleHashTableIndex
override	include/storage/index/extendible_hash_table_index.h	/^  ~ExtendibleHashTableIndex() override = default;$/;"	m	class:bustub::ExtendibleHashTableIndex
override	include/storage/index/linear_probe_hash_table_index.h	/^  void DeleteEntry(const Tuple &key, RID rid, Transaction *transaction) override;$/;"	m	class:bustub::LinearProbeHashTableIndex
override	include/storage/index/linear_probe_hash_table_index.h	/^  void InsertEntry(const Tuple &key, RID rid, Transaction *transaction) override;$/;"	m	class:bustub::LinearProbeHashTableIndex
override	include/storage/index/linear_probe_hash_table_index.h	/^  void ScanKey(const Tuple &key, std::vector<RID> *result, Transaction *transaction) override;$/;"	m	class:bustub::LinearProbeHashTableIndex
override	include/storage/index/linear_probe_hash_table_index.h	/^  ~LinearProbeHashTableIndex() override = default;$/;"	m	class:bustub::LinearProbeHashTableIndex
override	include/type/bigint_type.h	/^  auto Add(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto CastAs(const Value &val, TypeId type_id) const -> Value override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto CompareEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto CompareGreaterThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto CompareGreaterThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto CompareLessThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto CompareLessThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto CompareNotEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto Copy(const Value &val) const -> Value override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto DeserializeFrom(const char *storage) const -> Value override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto Divide(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto IsZero(const Value &val) const -> bool override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto Modulo(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto Multiply(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto OperateNull(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto Sqrt(const Value &val) const -> Value override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto Subtract(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  auto ToString(const Value &val) const -> std::string override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  void SerializeTo(const Value &val, char *storage) const override;$/;"	m	class:bustub::BigintType
override	include/type/bigint_type.h	/^  ~BigintType() override = default;$/;"	m	class:bustub::BigintType
override	include/type/boolean_type.h	/^  auto CastAs(const Value &val, TypeId type_id) const -> Value override;$/;"	m	class:bustub::BooleanType
override	include/type/boolean_type.h	/^  auto CompareEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::BooleanType
override	include/type/boolean_type.h	/^  auto CompareGreaterThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::BooleanType
override	include/type/boolean_type.h	/^  auto CompareGreaterThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::BooleanType
override	include/type/boolean_type.h	/^  auto CompareLessThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::BooleanType
override	include/type/boolean_type.h	/^  auto CompareLessThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::BooleanType
override	include/type/boolean_type.h	/^  auto CompareNotEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::BooleanType
override	include/type/boolean_type.h	/^  auto Copy(const Value &val) const -> Value override;$/;"	m	class:bustub::BooleanType
override	include/type/boolean_type.h	/^  auto DeserializeFrom(const char *storage) const -> Value override;$/;"	m	class:bustub::BooleanType
override	include/type/boolean_type.h	/^  auto ToString(const Value &val) const -> std::string override;$/;"	m	class:bustub::BooleanType
override	include/type/boolean_type.h	/^  void SerializeTo(const Value &val, char *storage) const override;$/;"	m	class:bustub::BooleanType
override	include/type/boolean_type.h	/^  ~BooleanType() override = default;$/;"	m	class:bustub::BooleanType
override	include/type/decimal_type.h	/^  auto Add(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto CastAs(const Value &val, TypeId type_id) const -> Value override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto CompareEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto CompareGreaterThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto CompareGreaterThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto CompareLessThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto CompareLessThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto CompareNotEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto Copy(const Value &val) const -> Value override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto DeserializeFrom(const char *storage) const -> Value override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto Divide(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto IsZero(const Value &val) const -> bool override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto Max(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto Min(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto Modulo(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto Multiply(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto OperateNull(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto Sqrt(const Value &val) const -> Value override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto Subtract(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  auto ToString(const Value &val) const -> std::string override;$/;"	m	class:bustub::DecimalType
override	include/type/decimal_type.h	/^  void SerializeTo(const Value &val, char *storage) const override;$/;"	m	class:bustub::DecimalType
override	include/type/integer_parent_type.h	/^  auto Add(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto CastAs(const Value &val, TypeId type_id) const -> Value override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto CompareEquals(const Value &left, const Value &right) const -> CmpBool override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto CompareGreaterThan(const Value &left, const Value &right) const -> CmpBool override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto CompareGreaterThanEquals(const Value &left, const Value &right) const -> CmpBool override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto CompareLessThan(const Value &left, const Value &right) const -> CmpBool override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto CompareLessThanEquals(const Value &left, const Value &right) const -> CmpBool override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto CompareNotEquals(const Value &left, const Value &right) const -> CmpBool override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto Copy(const Value &val) const -> Value override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto DeserializeFrom(const char *storage) const -> Value override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto Divide(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto IsZero(const Value &val) const -> bool override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto Max(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto Min(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto Modulo(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto Multiply(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto OperateNull(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto Sqrt(const Value &val) const -> Value override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto Subtract(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  auto ToString(const Value &val) const -> std::string override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  void SerializeTo(const Value &val, char *storage) const override = 0;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_parent_type.h	/^  ~IntegerParentType() override = default;$/;"	m	class:bustub::IntegerParentType
override	include/type/integer_type.h	/^  auto Add(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto CastAs(const Value &val, TypeId type_id) const -> Value override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto CompareEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto CompareGreaterThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto CompareGreaterThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto CompareLessThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto CompareLessThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto CompareNotEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto Copy(const Value &val) const -> Value override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto DeserializeFrom(const char *storage) const -> Value override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto Divide(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto IsZero(const Value &val) const -> bool override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto Modulo(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto Multiply(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto OperateNull(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto Sqrt(const Value &val) const -> Value override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto Subtract(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  auto ToString(const Value &val) const -> std::string override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  void SerializeTo(const Value &val, char *storage) const override;$/;"	m	class:bustub::IntegerType
override	include/type/integer_type.h	/^  ~IntegerType() override = default;$/;"	m	class:bustub::IntegerType
override	include/type/numeric_type.h	/^  auto Add(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::NumericType
override	include/type/numeric_type.h	/^  auto Divide(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::NumericType
override	include/type/numeric_type.h	/^  auto IsZero(const Value &val) const -> bool override = 0;$/;"	m	class:bustub::NumericType
override	include/type/numeric_type.h	/^  auto Max(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::NumericType
override	include/type/numeric_type.h	/^  auto Min(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::NumericType
override	include/type/numeric_type.h	/^  auto Modulo(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::NumericType
override	include/type/numeric_type.h	/^  auto Multiply(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::NumericType
override	include/type/numeric_type.h	/^  auto OperateNull(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::NumericType
override	include/type/numeric_type.h	/^  auto Sqrt(const Value &val) const -> Value override = 0;$/;"	m	class:bustub::NumericType
override	include/type/numeric_type.h	/^  auto Subtract(const Value &left, const Value &right) const -> Value override = 0;$/;"	m	class:bustub::NumericType
override	include/type/numeric_type.h	/^  ~NumericType() override = default;$/;"	m	class:bustub::NumericType
override	include/type/smallint_type.h	/^  auto Add(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto CastAs(const Value &val, TypeId type_id) const -> Value override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto CompareEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto CompareGreaterThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto CompareGreaterThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto CompareLessThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto CompareLessThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto CompareNotEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto Copy(const Value &val) const -> Value override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto DeserializeFrom(const char *storage) const -> Value override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto Divide(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto IsZero(const Value &val) const -> bool override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto Modulo(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto Multiply(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto OperateNull(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto Sqrt(const Value &val) const -> Value override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto Subtract(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  auto ToString(const Value &val) const -> std::string override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  void SerializeTo(const Value &val, char *storage) const override;$/;"	m	class:bustub::SmallintType
override	include/type/smallint_type.h	/^  ~SmallintType() override = default;$/;"	m	class:bustub::SmallintType
override	include/type/timestamp_type.h	/^  auto CastAs(const Value &val, TypeId type_id) const -> Value override;$/;"	m	class:bustub::TimestampType
override	include/type/timestamp_type.h	/^  auto CompareEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::TimestampType
override	include/type/timestamp_type.h	/^  auto CompareGreaterThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::TimestampType
override	include/type/timestamp_type.h	/^  auto CompareGreaterThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::TimestampType
override	include/type/timestamp_type.h	/^  auto CompareLessThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::TimestampType
override	include/type/timestamp_type.h	/^  auto CompareLessThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::TimestampType
override	include/type/timestamp_type.h	/^  auto CompareNotEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::TimestampType
override	include/type/timestamp_type.h	/^  auto Copy(const Value &val) const -> Value override;$/;"	m	class:bustub::TimestampType
override	include/type/timestamp_type.h	/^  auto DeserializeFrom(const char *storage) const -> Value override;$/;"	m	class:bustub::TimestampType
override	include/type/timestamp_type.h	/^  auto Max(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::TimestampType
override	include/type/timestamp_type.h	/^  auto Min(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::TimestampType
override	include/type/timestamp_type.h	/^  auto ToString(const Value &val) const -> std::string override;$/;"	m	class:bustub::TimestampType
override	include/type/timestamp_type.h	/^  void SerializeTo(const Value &val, char *storage) const override;$/;"	m	class:bustub::TimestampType
override	include/type/timestamp_type.h	/^  ~TimestampType() override = default;$/;"	m	class:bustub::TimestampType
override	include/type/tinyint_type.h	/^  auto Add(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto CastAs(const Value &val, TypeId type_id) const -> Value override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto CompareEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto CompareGreaterThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto CompareGreaterThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto CompareLessThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto CompareLessThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto CompareNotEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto Copy(const Value &val) const -> Value override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto DeserializeFrom(const char *storage) const -> Value override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto Divide(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto IsZero(const Value &val) const -> bool override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto Modulo(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto Multiply(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto OperateNull(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto Sqrt(const Value &val) const -> Value override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto Subtract(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  auto ToString(const Value &val) const -> std::string override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  void SerializeTo(const Value &val, char *storage) const override;$/;"	m	class:bustub::TinyintType
override	include/type/tinyint_type.h	/^  ~TinyintType() override = default;$/;"	m	class:bustub::TinyintType
override	include/type/varlen_type.h	/^  auto CastAs(const Value &value, TypeId type_id) const -> Value override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  auto CompareEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  auto CompareGreaterThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  auto CompareGreaterThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  auto CompareLessThan(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  auto CompareLessThanEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  auto CompareNotEquals(const Value &left, const Value &right) const -> CmpBool override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  auto Copy(const Value &val) const -> Value override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  auto DeserializeFrom(const char *storage) const -> Value override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  auto GetData(const Value &val) const -> const char * override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  auto GetLength(const Value &val) const -> uint32_t override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  auto Max(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  auto Min(const Value &left, const Value &right) const -> Value override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  auto ToString(const Value &val) const -> std::string override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  void SerializeTo(const Value &val, char *storage) const override;$/;"	m	class:bustub::VarlenType
override	include/type/varlen_type.h	/^  ~VarlenType() override;$/;"	m	class:bustub::VarlenType
page_id_	include/storage/page/b_plus_tree_page.h	/^  page_id_t page_id_ __attribute__((__unused__));$/;"	m	class:bustub::BPlusTreePage
page_id_	include/storage/page/hash_table_directory_page.h	/^  page_id_t page_id_;$/;"	m	class:bustub::HashTableDirectoryPage
page_id_	include/storage/page/hash_table_header_page.h	/^  __attribute__((unused)) page_id_t page_id_;$/;"	m	class:bustub::HashTableHeaderPage
page_id_	include/storage/page/page.h	/^  page_id_t page_id_ = INVALID_PAGE_ID;$/;"	m	class:bustub::Page
page_id_	include/storage/table/tmp_tuple.h	/^  page_id_t page_id_;$/;"	m	class:bustub::TmpTuple
page_id_t	include/storage/page/b_plus_tree_leaf_page.h	/^  auto GetNextPageId() const -> page_id_t;$/;"	m	class:bustub::BPlusTreeLeafPage
page_id_t	include/storage/page/b_plus_tree_page.h	/^  auto GetPageId() const -> page_id_t;$/;"	m	class:bustub::BPlusTreePage
page_id_t	include/storage/page/b_plus_tree_page.h	/^  auto GetParentPageId() const -> page_id_t;$/;"	m	class:bustub::BPlusTreePage
page_id_t	include/storage/page/hash_table_header_page.h	/^  auto GetBlockPageId(size_t index) -> page_id_t;$/;"	m	class:bustub::HashTableHeaderPage
page_id_t	include/storage/page/hash_table_header_page.h	/^  auto GetPageId() const -> page_id_t;$/;"	m	class:bustub::HashTableHeaderPage
page_set_	include/concurrency/transaction.h	/^  std::shared_ptr<std::deque<Page *>> page_set_;$/;"	m	class:bustub::Transaction
page_table_	include/buffer/buffer_pool_manager_instance.h	/^  std::unordered_map<page_id_t, frame_id_t> page_table_;$/;"	m	class:bustub::BufferPoolManagerInstance
page_type_	include/storage/page/b_plus_tree_page.h	/^  IndexPageType page_type_ __attribute__((__unused__));$/;"	m	class:bustub::BPlusTreePage
pages_	include/buffer/buffer_pool_manager_instance.h	/^  Page *pages_;$/;"	m	class:bustub::BufferPoolManagerInstance
parent_page_id_	include/storage/page/b_plus_tree_page.h	/^  page_id_t parent_page_id_ __attribute__((__unused__));$/;"	m	class:bustub::BPlusTreePage
persistent_lsn_	include/recovery/log_manager.h	/^  std::atomic<lsn_t> persistent_lsn_;$/;"	m	class:bustub::LogManager
pin_count_	include/storage/page/page.h	/^  int pin_count_ = 0;$/;"	m	class:bustub::Page
plan_	include/execution/executors/aggregation_executor.h	/^  const AggregationPlanNode *plan_;$/;"	m	class:bustub::AggregationExecutor
plan_	include/execution/executors/delete_executor.h	/^  const DeletePlanNode *plan_;$/;"	m	class:bustub::DeleteExecutor
plan_	include/execution/executors/distinct_executor.h	/^  const DistinctPlanNode *plan_;$/;"	m	class:bustub::DistinctExecutor
plan_	include/execution/executors/hash_join_executor.h	/^  const HashJoinPlanNode *plan_;$/;"	m	class:bustub::HashJoinExecutor
plan_	include/execution/executors/index_scan_executor.h	/^  const IndexScanPlanNode *plan_;$/;"	m	class:bustub::IndexScanExecutor
plan_	include/execution/executors/insert_executor.h	/^  const InsertPlanNode *plan_;$/;"	m	class:bustub::InsertExecutor
plan_	include/execution/executors/limit_executor.h	/^  const LimitPlanNode *plan_;$/;"	m	class:bustub::LimitExecutor
plan_	include/execution/executors/mock_scan_executor.h	/^  const MockScanPlanNode *plan_;$/;"	m	class:bustub::MockScanExecutor
plan_	include/execution/executors/nested_index_join_executor.h	/^  const NestedIndexJoinPlanNode *plan_;$/;"	m	class:bustub::NestIndexJoinExecutor
plan_	include/execution/executors/nested_loop_join_executor.h	/^  const NestedLoopJoinPlanNode *plan_;$/;"	m	class:bustub::NestedLoopJoinExecutor
plan_	include/execution/executors/seq_scan_executor.h	/^  const SeqScanPlanNode *plan_;$/;"	m	class:bustub::SeqScanExecutor
plan_	include/execution/executors/update_executor.h	/^  const UpdatePlanNode *plan_;$/;"	m	class:bustub::UpdateExecutor
poll_count_	include/execution/plans/mock_scan_plan.h	/^  mutable std::size_t poll_count_;$/;"	m	class:bustub::MockScanPlanNode
pool_size_	include/buffer/buffer_pool_manager_instance.h	/^  const size_t pool_size_;$/;"	m	class:bustub::BufferPoolManagerInstance
predicate_	include/execution/plans/index_scan_plan.h	/^  const AbstractExpression *predicate_;$/;"	m	class:bustub::IndexScanPlanNode
predicate_	include/execution/plans/nested_index_join_plan.h	/^  const AbstractExpression *predicate_;$/;"	m	class:bustub::NestedIndexJoinPlanNode
predicate_	include/execution/plans/nested_loop_join_plan.h	/^  const AbstractExpression *predicate_;$/;"	m	class:bustub::NestedLoopJoinPlanNode
predicate_	include/execution/plans/seq_scan_plan.h	/^  const AbstractExpression *predicate_;$/;"	m	class:bustub::SeqScanPlanNode
prev_lsn_	include/concurrency/transaction.h	/^  lsn_t prev_lsn_;$/;"	m	class:bustub::Transaction
raw_values_	include/execution/plans/insert_plan.h	/^  std::vector<std::vector<Value>> raw_values_;$/;"	m	class:bustub::InsertPlanNode
readable_	include/storage/page/hash_table_block_page.h	/^  std::atomic_char readable_[(BLOCK_ARRAY_SIZE - 1) \/ 8 + 1];$/;"	m	class:bustub::HashTableBlockPage
readable_	include/storage/page/hash_table_bucket_page.h	/^  char readable_[(BUCKET_ARRAY_SIZE - 1) \/ 8 + 1];$/;"	m	class:bustub::HashTableBucketPage
reader_	include/common/rwlatch.h	/^  cond_t reader_;$/;"	m	class:bustub::ReaderWriterLatch
replacer_	include/buffer/buffer_pool_manager_instance.h	/^  Replacer *replacer_;$/;"	m	class:bustub::BufferPoolManagerInstance
request_queue_	include/concurrency/lock_manager.h	/^    std::list<LockRequest> request_queue_;$/;"	m	class:bustub::LockManager::LockRequestQueue
ret_type_	include/execution/expressions/abstract_expression.h	/^  TypeId ret_type_;$/;"	m	class:bustub::AbstractExpression
rid_	include/concurrency/transaction.h	/^  RID rid_;$/;"	m	class:bustub::IndexWriteRecord
rid_	include/concurrency/transaction.h	/^  RID rid_;$/;"	m	class:bustub::TableWriteRecord
right_child_	include/execution/executors/hash_join_executor.h	/^  std::unique_ptr<AbstractExecutor> right_child_;$/;"	m	class:bustub::HashJoinExecutor
right_executor_	include/execution/executors/nested_loop_join_executor.h	/^  std::unique_ptr<AbstractExecutor> right_executor_;$/;"	m	class:bustub::NestedLoopJoinExecutor
right_key_expression_	include/execution/plans/hash_join_plan.h	/^  const AbstractExpression *right_key_expression_;$/;"	m	class:bustub::HashJoinPlanNode
root_page_id_	include/storage/index/b_plus_tree.h	/^  page_id_t root_page_id_;$/;"	m	class:bustub::BPlusTree
rows_	include/primer/p0_starter.h	/^  int rows_;$/;"	m	class:bustub::Matrix
rwlatch_	include/storage/page/page.h	/^  ReaderWriterLatch rwlatch_;$/;"	m	class:bustub::Page
schema_	include/catalog/catalog.h	/^  Schema schema_;$/;"	m	struct:bustub::TableInfo
set_	include/execution/executors/distinct_executor.h	/^  std::unordered_set<DistinctKey> set_;$/;"	m	class:bustub::DistinctExecutor
shared_lock_set_	include/concurrency/transaction.h	/^  std::shared_ptr<std::unordered_set<RID>> shared_lock_set_;$/;"	m	class:bustub::Transaction
size_	include/execution/executors/insert_executor.h	/^  uint32_t size_;$/;"	m	class:bustub::InsertExecutor
size_	include/execution/plans/mock_scan_plan.h	/^  const std::size_t size_;$/;"	m	class:bustub::MockScanPlanNode
size_	include/storage/page/b_plus_tree_page.h	/^  int size_ __attribute__((__unused__));$/;"	m	class:bustub::BPlusTreePage
size_	include/storage/page/hash_table_header_page.h	/^  __attribute__((unused)) size_t size_;$/;"	m	class:bustub::HashTableHeaderPage
size_	include/type/value.h	/^  } size_;$/;"	m	class:bustub::Value	typeref:union:bustub::Value::__anon1
size_t	include/buffer/buffer_pool_manager.h	/^  virtual auto GetPoolSize() -> size_t = 0;$/;"	m	class:bustub::BufferPoolManager
size_t	include/buffer/replacer.h	/^  virtual auto Size() -> size_t = 0;$/;"	m	class:bustub::Replacer
size_t	include/container/hash/linear_probe_hash_table.h	/^  auto GetSize() -> size_t;$/;"	m	class:bustub::LinearProbeHashTable
size_t	include/storage/page/hash_table_header_page.h	/^  auto GetSize() const -> size_t;$/;"	m	class:bustub::HashTableHeaderPage
size_t	include/storage/page/hash_table_header_page.h	/^  auto NumBlocks() -> size_t;$/;"	m	class:bustub::HashTableHeaderPage
smallint_	include/type/value.h	/^    int16_t smallint_;$/;"	m	union:bustub::Value::Val
state_	include/concurrency/transaction.h	/^  TransactionState state_;$/;"	m	class:bustub::Transaction
std	include/common/rid.h	/^namespace std {$/;"	n
std	include/execution/executors/distinct_executor.h	/^namespace std {$/;"	n
std	include/execution/executors/hash_join_executor.h	/^namespace std {$/;"	n
std	include/execution/plans/aggregation_plan.h	/^namespace std {$/;"	n
string	include/catalog/column.h	/^  auto ToString() const -> std::string;$/;"	m	class:bustub::Column::std
string	include/catalog/schema.h	/^  auto ToString() const -> std::string;$/;"	m	class:bustub::Schema::std
string	include/common/util/string_util.h	/^  static auto Bold(const std::string &str) -> std::string;$/;"	m	class:bustub::StringUtil::std
string	include/common/util/string_util.h	/^  static auto Format(std::string fmt_str, ...) -> std::string;$/;"	m	class:bustub::StringUtil::std
string	include/common/util/string_util.h	/^  static auto FormatSize(uint64_t bytes) -> std::string;$/;"	m	class:bustub::StringUtil::std
string	include/common/util/string_util.h	/^  static auto Indent(int num_indent) -> std::string;$/;"	m	class:bustub::StringUtil::std
string	include/common/util/string_util.h	/^  static auto Join(const std::vector<std::string> &input, const std::string &separator) -> std::string;$/;"	m	class:bustub::StringUtil::std
string	include/common/util/string_util.h	/^  static auto Lower(const std::string &str) -> std::string;$/;"	m	class:bustub::StringUtil::std
string	include/common/util/string_util.h	/^  static auto Prefix(const std::string &str, const std::string &prefix) -> std::string;$/;"	m	class:bustub::StringUtil::std
string	include/common/util/string_util.h	/^  static auto Repeat(const std::string &str, std::size_t n) -> std::string;$/;"	m	class:bustub::StringUtil::std
string	include/common/util/string_util.h	/^  static auto Strip(const std::string &str, char c) -> std::string;$/;"	m	class:bustub::StringUtil::std
string	include/common/util/string_util.h	/^  static auto Upper(const std::string &str) -> std::string;$/;"	m	class:bustub::StringUtil::std
string	include/storage/table/tuple.h	/^  auto ToString(const Schema *schema) const -> std::string;$/;"	m	class:bustub::Tuple::std
string	include/type/type.h	/^  static auto TypeIdToString(TypeId type_id) -> std::string;$/;"	m	class:bustub::CmpBool::Type::std
string	include/type/type.h	/^  virtual auto ToString(const Value &val) const -> std::string;$/;"	m	class:bustub::CmpBool::Type::std
table_	include/catalog/catalog.h	/^  std::unique_ptr<TableHeap> table_;$/;"	m	struct:bustub::TableInfo
table_	include/concurrency/transaction.h	/^  TableHeap *table_;$/;"	m	class:bustub::TableWriteRecord
table_heap_	include/storage/table/table_iterator.h	/^  TableHeap *table_heap_;$/;"	m	class:bustub::TableIterator
table_info_	include/execution/executors/delete_executor.h	/^  const TableInfo *table_info_;$/;"	m	class:bustub::DeleteExecutor
table_info_	include/execution/executors/insert_executor.h	/^  TableInfo *table_info_;$/;"	m	class:bustub::InsertExecutor
table_info_	include/execution/executors/seq_scan_executor.h	/^  TableInfo *table_info_;$/;"	m	class:bustub::SeqScanExecutor
table_info_	include/execution/executors/update_executor.h	/^  const TableInfo *table_info_;$/;"	m	class:bustub::UpdateExecutor
table_latch_	include/container/hash/extendible_hash_table.h	/^  ReaderWriterLatch table_latch_;$/;"	m	class:bustub::ExtendibleHashTable
table_latch_	include/container/hash/linear_probe_hash_table.h	/^  ReaderWriterLatch table_latch_;$/;"	m	class:bustub::LinearProbeHashTable
table_name_	include/catalog/catalog.h	/^  std::string table_name_;$/;"	m	struct:bustub::IndexInfo
table_name_	include/storage/index/index.h	/^  std::string table_name_;$/;"	m	class:bustub::IndexMetadata
table_names_	include/catalog/catalog.h	/^  std::unordered_map<std::string, table_oid_t> table_names_;$/;"	m	class:bustub::Catalog
table_oid_	include/concurrency/transaction.h	/^  table_oid_t table_oid_;$/;"	m	class:bustub::IndexWriteRecord
table_oid_	include/execution/plans/delete_plan.h	/^  table_oid_t table_oid_;$/;"	m	class:bustub::DeletePlanNode
table_oid_	include/execution/plans/insert_plan.h	/^  table_oid_t table_oid_;$/;"	m	class:bustub::InsertPlanNode
table_oid_	include/execution/plans/seq_scan_plan.h	/^  table_oid_t table_oid_;$/;"	m	class:bustub::SeqScanPlanNode
table_oid_	include/execution/plans/update_plan.h	/^  table_oid_t table_oid_;$/;"	m	class:bustub::UpdatePlanNode
table_write_set_	include/concurrency/transaction.h	/^  std::shared_ptr<std::deque<TableWriteRecord>> table_write_set_;$/;"	m	class:bustub::Transaction
tables_	include/catalog/catalog.h	/^  std::unordered_map<table_oid_t, std::unique_ptr<TableInfo>> tables_;$/;"	m	class:bustub::Catalog
tail_	include/buffer/lru_replacer.h	/^  LinkListNode *tail_;$/;"	m	class:bustub::LRUReplacer
term_idx_	include/execution/expressions/aggregate_value_expression.h	/^  uint32_t term_idx_;$/;"	m	class:bustub::AggregateValueExpression
thread_id_	include/concurrency/transaction.h	/^  std::thread::id thread_id_;$/;"	m	class:bustub::Transaction
timestamp_	include/type/value.h	/^    uint64_t timestamp_;$/;"	m	union:bustub::Value::Val
tinyint_	include/type/value.h	/^    int8_t tinyint_;$/;"	m	union:bustub::Value::Val
transaction_	include/execution/executor_context.h	/^  Transaction *transaction_;$/;"	m	class:bustub::ExecutorContext
transaction_manager_	include/common/bustub_instance.h	/^  TransactionManager *transaction_manager_;$/;"	m	class:bustub::BustubInstance
transaction_manager_	include/recovery/checkpoint_manager.h	/^  TransactionManager *transaction_manager_ __attribute__((__unused__));$/;"	m	class:bustub::CheckpointManager
tuple_	include/concurrency/transaction.h	/^  Tuple tuple_;$/;"	m	class:bustub::IndexWriteRecord
tuple_	include/concurrency/transaction.h	/^  Tuple tuple_;$/;"	m	class:bustub::TableWriteRecord
tuple_	include/storage/table/table_iterator.h	/^  Tuple *tuple_;$/;"	m	class:bustub::TableIterator
tuple_idx_	include/execution/expressions/column_value_expression.h	/^  uint32_t tuple_idx_;$/;"	m	class:bustub::ColumnValueExpression
tuple_is_inlined_	include/catalog/schema.h	/^  bool tuple_is_inlined_;$/;"	m	class:bustub::Schema
txn_	include/storage/table/table_iterator.h	/^  Transaction *txn_;$/;"	m	class:bustub::TableIterator
txn_id_	include/concurrency/lock_manager.h	/^    txn_id_t txn_id_;$/;"	m	class:bustub::LockManager::LockRequest
txn_id_	include/concurrency/transaction.h	/^  txn_id_t txn_id_;$/;"	m	class:bustub::Transaction
txn_id_	include/concurrency/transaction.h	/^  txn_id_t txn_id_;$/;"	m	class:bustub::TransactionAbortException
txn_map	concurrency/transaction_manager.cpp	/^std::unordered_map<txn_id_t, Transaction *> TransactionManager::txn_map = {};$/;"	m	class:bustub::TransactionManager	file:
txn_map	include/concurrency/transaction_manager.h	/^  static std::unordered_map<txn_id_t, Transaction *> txn_map;$/;"	m	class:bustub::TransactionManager
txn_map_mutex	concurrency/transaction_manager.cpp	/^std::shared_mutex TransactionManager::txn_map_mutex = {};$/;"	m	class:bustub::TransactionManager	file:
txn_map_mutex	include/concurrency/transaction_manager.h	/^  static std::shared_mutex txn_map_mutex;$/;"	m	class:bustub::TransactionManager
txn_mgr_	include/execution/execution_engine.h	/^  [[maybe_unused]] TransactionManager *txn_mgr_;$/;"	m	class:bustub::ExecutionEngine
txn_mgr_	include/execution/executor_context.h	/^  TransactionManager *txn_mgr_;$/;"	m	class:bustub::ExecutorContext
type_	include/catalog/table_generator.h	/^    const TypeId type_;$/;"	m	struct:bustub::TableGenerator::ColumnInsertMeta
type_	include/common/exception.h	/^  ExceptionType type_;$/;"	m	class:bustub::Exception
type_	include/execution/plans/update_plan.h	/^  UpdateType type_;$/;"	m	struct:bustub::UpdateInfo
type_id_	include/type/type.h	/^  TypeId type_id_;$/;"	m	class:bustub::CmpBool::Type
type_id_	include/type/value.h	/^  TypeId type_id_;$/;"	m	class:bustub::Value
uint32_t	include/storage/page/hash_table_block_page.h	/^  auto NumReadable() -> uint32_t;$/;"	m	class:bustub::HashTableBlockPage
uint32_t	include/type/type.h	/^  virtual auto GetLength(const Value &val) const -> uint32_t;$/;"	m	class:bustub::CmpBool::Type
uint64_t	include/type/type.h	/^  static auto GetTypeSize(TypeId type_id) -> uint64_t;$/;"	m	class:bustub::CmpBool::Type
uninlined_columns_	include/catalog/schema.h	/^  std::vector<uint32_t> uninlined_columns_;$/;"	m	class:bustub::Schema
unique_ptr	include/execution/executor_factory.h	/^      -> std::unique_ptr<AbstractExecutor>;$/;"	m	class:bustub::ExecutorFactory::std
update_attrs_	include/execution/plans/update_plan.h	/^  const std::unordered_map<uint32_t, UpdateInfo> update_attrs_;$/;"	m	class:bustub::UpdatePlanNode
update_rid_	include/recovery/log_record.h	/^  RID update_rid_;$/;"	m	class:bustub::LogRecord
update_val_	include/execution/plans/update_plan.h	/^  int update_val_;$/;"	m	struct:bustub::UpdateInfo
upgrading_	include/concurrency/lock_manager.h	/^    txn_id_t upgrading_ = INVALID_TXN_ID;$/;"	m	class:bustub::LockManager::LockRequestQueue
val_	include/execution/expressions/constant_value_expression.h	/^  Value val_;$/;"	m	class:bustub::ConstantValueExpression
value_	include/execution/executors/distinct_executor.h	/^  std::vector<Value> value_;$/;"	m	struct:bustub::DistinctKey
value_	include/execution/executors/hash_join_executor.h	/^  Value value_;$/;"	m	struct:bustub::HashJoinKey
value_	include/type/value.h	/^  } value_;$/;"	m	class:bustub::Value	typeref:union:bustub::Value::Val
varlen_	include/type/value.h	/^    char *varlen_;$/;"	m	union:bustub::Value::Val
vector	include/catalog/table_generator.h	/^  auto GenNumericValues(ColumnInsertMeta *col_meta, uint32_t count) -> std::vector<Value>;$/;"	m	class:bustub::TableGenerator::std
vector	include/catalog/table_generator.h	/^  auto MakeValues(ColumnInsertMeta *col_meta, uint32_t count) -> std::vector<Value>;$/;"	m	class:bustub::TableGenerator::std
vector	include/common/util/string_util.h	/^  static auto Split(const std::string &input, const std::string &split) -> std::vector<std::string>;$/;"	m	class:bustub::StringUtil::std
vector	include/common/util/string_util.h	/^  static auto Split(const std::string &str, char delimiter) -> std::vector<std::string>;$/;"	m	class:bustub::StringUtil::std
writer_	include/common/rwlatch.h	/^  cond_t writer_;$/;"	m	class:bustub::ReaderWriterLatch
wtype_	include/concurrency/transaction.h	/^  WType wtype_;$/;"	m	class:bustub::IndexWriteRecord
wtype_	include/concurrency/transaction.h	/^  WType wtype_;$/;"	m	class:bustub::TableWriteRecord
~BufferPoolManagerInstance	buffer/buffer_pool_manager_instance.cpp	/^BufferPoolManagerInstance::~BufferPoolManagerInstance() {$/;"	f	class:bustub::BufferPoolManagerInstance
~BustubInstance	include/common/bustub_instance.h	/^  ~BustubInstance() {$/;"	f	class:bustub::BustubInstance
~IndexMetadata	include/storage/index/index.h	/^  ~IndexMetadata() { delete key_schema_; }$/;"	f	class:bustub::IndexMetadata
~LRUReplacer	buffer/lru_replacer.cpp	/^LRUReplacer::~LRUReplacer() {$/;"	f	class:bustub::LRUReplacer
~LogManager	include/recovery/log_manager.h	/^  ~LogManager() {$/;"	f	class:bustub::LogManager
~LogRecovery	include/recovery/log_recovery.h	/^  ~LogRecovery() {$/;"	f	class:bustub::LogRecovery
~Matrix	include/primer/p0_starter.h	/^  virtual ~Matrix() { delete[] linear_; }$/;"	f	class:bustub::Matrix
~ReaderWriterLatch	include/common/rwlatch.h	/^  ~ReaderWriterLatch() { std::lock_guard<mutex_t> guard(mutex_); }$/;"	f	class:bustub::ReaderWriterLatch
~TableIterator	include/storage/table/table_iterator.h	/^  ~TableIterator() { delete tuple_; }$/;"	f	class:bustub::TableIterator
~Tuple	include/storage/table/tuple.h	/^  ~Tuple() {$/;"	f	class:bustub::Tuple
~Value	type/value.cpp	/^Value::~Value() {$/;"	f	class:bustub::Value
